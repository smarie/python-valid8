# ----
# This file is generated by mini_lambda_methods_generation.py - do not modify it !
# ----
from valid8.mini_lambda_base import StackableFunctionEvaluator, evaluate
from sys import getsizeof

class _InputEvaluatorGenerated(StackableFunctionEvaluator):
    """
    This generated class implements a bunch of magic methods, so that calling these magic methods on an object will
    result in adding that magic method to the StackableFunctionEvaluator's stack.
    This allows for example x[1] to return a new _InputEvaluatorGenerated whose stack is able to call [1] (getitem(1))
    on the result of the current stack's evaluation

    The methods added below belong to two categories
     * All magic methods that 'just' need to be implemented (for example __add__), or remapped to the original method
     calling them because on some built-in data types the magic method does not exist (for example, __getattr__ should
     not add __getattr__ to the stack but getattr)
     * All magic methods that do not work because the python framework does not allow them to return another type than
     the expected one. For all of them there are two methods: one in the class throwing an exception, and one at
     package-level to provide a replacement (The exception message provides the replacement method name).
    """

    # ******* All magic methods that need to be implemented ********

    ## For each method to override
    % for o in to_override:
        % if o.self_operator:
    ## ----------method applies an operator to self, such as '-'-------------------
    def ${o.method_name}(self):
        """ Returns a new _InputEvaluator performing '${o.self_operator}<r>' on the result <r> of this evaluator's evaluation """
        ## def _${o.method_name}(r, input):
        ##     return ${o.self_operator}r
        ## return self.add_unbound_method_to_stack(_${o.method_name})
        def _${o.method_name}(input):
            # first evaluate the inner function
            res = self.evaluate(input)
            # then call the method
            return ${o.self_operator}res

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(_${o.method_name})

    ## -----------------------------
        % elif o.operator:
            % if o.is_operator_left:
    ## --------pairwise operator - left---------------------
    def ${o.method_name}(self, other):
        """ Returns a new _InputEvaluator performing '<r> ${o.operator} other' on the result <r> of this evaluator's evaluation """
        ## def _${o.method_name}(r, input):
        ##    return r ${o.operator} evaluate(other, input)
        ## return self.add_unbound_method_to_stack(_${o.method_name})
        def _${o.method_name}(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r ${o.operator} evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(_${o.method_name})

    ## -----------------------------
            % else:
    ## --------pairwise operator - left---------------------
    def ${o.method_name}(self, other):
        """ Returns a new _InputEvaluator performing 'other ${o.operator} <r>' on the result <r> of this evaluator's evaluation """
        ## def _${o.method_name}(r, input):
        ##     return evaluate(other, input) ${o.operator} r
        ## return self.add_unbound_method_to_stack(_${o.method_name})
        def _${o.method_name}(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return evaluate(other, input) ${o.operator} r

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(_${o.method_name})

    ## -----------------------------
            % endif
        % elif o.unbound_method:
    ## --------unbound method---------------------
    def ${o.method_name}(self, *args):
        """ Returns a new _InputEvaluator performing '${o.unbound_method.__name__}(<r>, *args)' on the result <r> of this evaluator's evaluation """
        ## def _${o.method_name}(r, input, *args):
        ##     return ${o.unbound_method.__name__}(r, input, *args)
        ## return self.add_unbound_method_to_stack(_${o.method_name}, *args)
        def _${o.method_name}(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return ${o.unbound_method.__name__}(r, *args)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(_${o.method_name})

    ## -----------------------------
        % else:
    ## --------general case---------------------
    def ${o.method_name}(self, *args):
        """ Returns a new _InputEvaluator performing '<r>.${o.method_name}(*args)' on the result <r> of this evaluator's evaluation """
        return self.add_bound_method_to_stack('${o.method_name}', *args)

    ## -----------------------------
        % endif
    % endfor
    # ******* All magic methods that need to raise an exception ********
    ## For each method to override
    % for o in to_override_with_exception:
    def ${o.method_name}(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('${o.method_name} is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the ${o.module_method_name}() method provided at valid8 package level instead')

    % endfor

# ******* All replacement methods for the magic methods throwing exceptions ********
% for o in to_override_with_exception:
def ${o.module_method_name}(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '${o.method_name}' magic method """
    % if o.unbound_method:
    return evaluator.add_unbound_method_to_stack(${o.unbound_method.__name__})
    % else:
    return evaluator.add_bound_method_to_stack('${o.method_name}')
    % endif

% endfor