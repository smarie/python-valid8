# ----
# This file is generated by mini_lambda_methods_generation.py - do not modify it !
# ----
from valid8.mini_lambda_base import StackableFunctionEvaluator, evaluate
from sys import getsizeof

class _InputEvaluatorGenerated(StackableFunctionEvaluator):
    """
    This generated class implements a bunch of magic methods, so that calling these magic methods on an object will
    result in adding that magic method to the StackableFunctionEvaluator's stack.
    This allows for example x[1] to return a new _InputEvaluatorGenerated whose stack is able to call [1] (getitem(1))
    on the result of the current stack's evaluation

    The methods added below belong to two categories
     * All magic methods that 'just' need to be implemented (for example __add__), or remapped to the original method
     calling them because on some built-in data types the magic method does not exist (for example, __getattr__ should
     not add __getattr__ to the stack but getattr)
     * All magic methods that do not work because the python framework does not allow them to return another type than
     the expected one. For all of them there are two methods: one in the class throwing an exception, and one at
     package-level to provide a replacement (The exception message provides the replacement method name).
    """

    # ******* All magic methods that need to be implemented ********

    def __next__(self, *args):
        """ Returns a new _InputEvaluator performing 'next(<r>, *args)' on the result <r> of this evaluator's evaluation """
        def ___next__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return next(r, *args)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___next__)

    def __ne__(self, other):
        """ Returns a new _InputEvaluator performing '<r> != other' on the result <r> of this evaluator's evaluation """
        def ___ne__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r != evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___ne__)

    def __le__(self, other):
        """ Returns a new _InputEvaluator performing '<r> <= other' on the result <r> of this evaluator's evaluation """
        def ___le__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r <= evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___le__)

    def __eq__(self, other):
        """ Returns a new _InputEvaluator performing '<r> == other' on the result <r> of this evaluator's evaluation """
        def ___eq__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r == evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___eq__)

    def __lt__(self, other):
        """ Returns a new _InputEvaluator performing '<r> < other' on the result <r> of this evaluator's evaluation """
        def ___lt__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r < evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___lt__)

    def __ge__(self, other):
        """ Returns a new _InputEvaluator performing '<r> >= other' on the result <r> of this evaluator's evaluation """
        def ___ge__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r >= evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___ge__)

    def __gt__(self, other):
        """ Returns a new _InputEvaluator performing '<r> > other' on the result <r> of this evaluator's evaluation """
        def ___gt__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r > evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___gt__)

    def __getattr__(self, *args):
        """ Returns a new _InputEvaluator performing 'getattr(<r>, *args)' on the result <r> of this evaluator's evaluation """
        def ___getattr__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return getattr(r, *args)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___getattr__)

    def __call__(self, *args):
        """ Returns a new _InputEvaluator performing '<r>.__call__(*args)' on the result <r> of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__call__', *args)

    def __reversed__(self, *args):
        """ Returns a new _InputEvaluator performing 'reversed(<r>, *args)' on the result <r> of this evaluator's evaluation """
        def ___reversed__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return reversed(r, *args)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___reversed__)

    def __getitem__(self, *args):
        """ Returns a new _InputEvaluator performing '<r>.__getitem__(*args)' on the result <r> of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__getitem__', *args)

    def __missing__(self, *args):
        """ Returns a new _InputEvaluator performing '<r>.__missing__(*args)' on the result <r> of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__missing__', *args)

    def __rtruediv__(self, other):
        """ Returns a new _InputEvaluator performing 'other / <r>' on the result <r> of this evaluator's evaluation """
        def ___rtruediv__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return evaluate(other, input) / r

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___rtruediv__)

    def __divmod__(self, *args):
        """ Returns a new _InputEvaluator performing '<r>.__divmod__(*args)' on the result <r> of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__divmod__', *args)

    def __mul__(self, other):
        """ Returns a new _InputEvaluator performing '<r> * other' on the result <r> of this evaluator's evaluation """
        def ___mul__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r * evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___mul__)

    def __rmul__(self, other):
        """ Returns a new _InputEvaluator performing 'other * <r>' on the result <r> of this evaluator's evaluation """
        def ___rmul__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return evaluate(other, input) * r

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___rmul__)

    def __add__(self, other):
        """ Returns a new _InputEvaluator performing '<r> + other' on the result <r> of this evaluator's evaluation """
        def ___add__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r + evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___add__)

    def __radd__(self, other):
        """ Returns a new _InputEvaluator performing 'other + <r>' on the result <r> of this evaluator's evaluation """
        def ___radd__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return evaluate(other, input) + r

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___radd__)

    def __pos__(self):
        """ Returns a new _InputEvaluator performing '+<r>' on the result <r> of this evaluator's evaluation """
        def ___pos__(input):
            # first evaluate the inner function
            res = self.evaluate(input)
            # then call the method
            return +res

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___pos__)

    def __rfloordiv__(self, other):
        """ Returns a new _InputEvaluator performing 'other // <r>' on the result <r> of this evaluator's evaluation """
        def ___rfloordiv__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return evaluate(other, input) // r

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___rfloordiv__)

    def __rlshift__(self, other):
        """ Returns a new _InputEvaluator performing 'other << <r>' on the result <r> of this evaluator's evaluation """
        def ___rlshift__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return evaluate(other, input) << r

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___rlshift__)

    def __pow__(self, other):
        """ Returns a new _InputEvaluator performing '<r> ** other' on the result <r> of this evaluator's evaluation """
        def ___pow__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r ** evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___pow__)

    def __rrshift__(self, other):
        """ Returns a new _InputEvaluator performing 'other >> <r>' on the result <r> of this evaluator's evaluation """
        def ___rrshift__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return evaluate(other, input) >> r

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___rrshift__)

    def __matmul__(self, other):
        """ Returns a new _InputEvaluator performing '<r> @ other' on the result <r> of this evaluator's evaluation """
        def ___matmul__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r @ evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___matmul__)

    def __rpow__(self, other):
        """ Returns a new _InputEvaluator performing 'other ** <r>' on the result <r> of this evaluator's evaluation """
        def ___rpow__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return evaluate(other, input) ** r

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___rpow__)

    def __truediv__(self, other):
        """ Returns a new _InputEvaluator performing '<r> / other' on the result <r> of this evaluator's evaluation """
        def ___truediv__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r / evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___truediv__)

    def __invert__(self):
        """ Returns a new _InputEvaluator performing '~<r>' on the result <r> of this evaluator's evaluation """
        def ___invert__(input):
            # first evaluate the inner function
            res = self.evaluate(input)
            # then call the method
            return ~res

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___invert__)

    def __rdivmod__(self, *args):
        """ Returns a new _InputEvaluator performing '<r>.__rdivmod__(*args)' on the result <r> of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rdivmod__', *args)

    def __abs__(self, *args):
        """ Returns a new _InputEvaluator performing 'abs(<r>, *args)' on the result <r> of this evaluator's evaluation """
        def ___abs__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return abs(r, *args)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___abs__)

    def __lshift__(self, other):
        """ Returns a new _InputEvaluator performing '<r> << other' on the result <r> of this evaluator's evaluation """
        def ___lshift__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r << evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___lshift__)

    def __mod__(self, other):
        """ Returns a new _InputEvaluator performing '<r> % other' on the result <r> of this evaluator's evaluation """
        def ___mod__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r % evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___mod__)

    def __sub__(self, other):
        """ Returns a new _InputEvaluator performing '<r> - other' on the result <r> of this evaluator's evaluation """
        def ___sub__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r - evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___sub__)

    def __rsub__(self, other):
        """ Returns a new _InputEvaluator performing 'other - <r>' on the result <r> of this evaluator's evaluation """
        def ___rsub__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return evaluate(other, input) - r

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___rsub__)

    def __rmod__(self, other):
        """ Returns a new _InputEvaluator performing 'other % <r>' on the result <r> of this evaluator's evaluation """
        def ___rmod__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return evaluate(other, input) % r

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___rmod__)

    def __neg__(self):
        """ Returns a new _InputEvaluator performing '-<r>' on the result <r> of this evaluator's evaluation """
        def ___neg__(input):
            # first evaluate the inner function
            res = self.evaluate(input)
            # then call the method
            return -res

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___neg__)

    def __rshift__(self, other):
        """ Returns a new _InputEvaluator performing '<r> >> other' on the result <r> of this evaluator's evaluation """
        def ___rshift__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r >> evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___rshift__)

    def __floordiv__(self, other):
        """ Returns a new _InputEvaluator performing '<r> // other' on the result <r> of this evaluator's evaluation """
        def ___floordiv__(input):
            # first evaluate the inner function
            r = self.evaluate(input)
            # then call the method
            return r // evaluate(other, input)

        # return a new InputEvaluator of the same type than self, with the new function as inner function
        return type(self)(___floordiv__)

    def __trunc__(self, *args):
        """ Returns a new _InputEvaluator performing '<r>.__trunc__(*args)' on the result <r> of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__trunc__', *args)

    def __coerce__(self, *args):
        """ Returns a new _InputEvaluator performing '<r>.__coerce__(*args)' on the result <r> of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__coerce__', *args)

    # ******* All magic methods that need to raise an exception ********
    def __iter__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__iter__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Iter() method provided at valid8 package level instead')

    def __str__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__str__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Str() method provided at valid8 package level instead')

    def __sizeof__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__sizeof__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Sizeof() method provided at valid8 package level instead')

    def __bytes__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__bytes__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Bytes() method provided at valid8 package level instead')

    def __format__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__format__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Format() method provided at valid8 package level instead')

    def __repr__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__repr__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Repr() method provided at valid8 package level instead')

    def __hash__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__hash__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Hash() method provided at valid8 package level instead')

    def __bool__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__bool__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Bool() method provided at valid8 package level instead')

    def __len__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__len__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Len() method provided at valid8 package level instead')

    def __float__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__float__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Float() method provided at valid8 package level instead')

    def __oct__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__oct__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Oct() method provided at valid8 package level instead')

    def __int__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__int__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Int() method provided at valid8 package level instead')

    def __hex__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__hex__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Hex() method provided at valid8 package level instead')

    def __complex__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__complex__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Complex() method provided at valid8 package level instead')


# ******* All replacement methods for the magic methods throwing exceptions ********
def Iter(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__iter__' magic method """
    return evaluator.add_bound_method_to_stack('__iter__')

def Str(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__str__' magic method """
    return evaluator.add_unbound_method_to_stack(str)

def Sizeof(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__sizeof__' magic method """
    return evaluator.add_unbound_method_to_stack(getsizeof)

def Bytes(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__bytes__' magic method """
    return evaluator.add_unbound_method_to_stack(bytes)

def Format(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__format__' magic method """
    return evaluator.add_unbound_method_to_stack(format)

def Repr(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__repr__' magic method """
    return evaluator.add_unbound_method_to_stack(repr)

def Hash(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__hash__' magic method """
    return evaluator.add_bound_method_to_stack('__hash__')

def Bool(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__bool__' magic method """
    return evaluator.add_bound_method_to_stack('__bool__')

def Len(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__len__' magic method """
    return evaluator.add_bound_method_to_stack('__len__')

def Float(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__float__' magic method """
    return evaluator.add_unbound_method_to_stack(float)

def Oct(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__oct__' magic method """
    return evaluator.add_unbound_method_to_stack(oct)

def Int(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__int__' magic method """
    return evaluator.add_unbound_method_to_stack(int)

def Hex(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__hex__' magic method """
    return evaluator.add_unbound_method_to_stack(hex)

def Complex(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__complex__' magic method """
    return evaluator.add_unbound_method_to_stack(complex)

