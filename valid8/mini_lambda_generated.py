# ----
# This file is generated by mini_lambda_methods_generation.py - do not modify it !
# ----
from valid8.mini_lambda_base import StackableFunctionEvaluator


class _InputEvaluatorGenerated(StackableFunctionEvaluator):
    """
    This generated class implements a bunch of magic methods, so that calling these magic methods on an object will
    result in adding that magic method to the StackableFunctionEvaluator's stack.
    This allows for example x[1] to return a new _InputEvaluatorGenerated whose stack is able to call [1] (getitem(1))
    on the result of the current stack's evaluation

    The methods added below belong to two categories
     * All magic methods that 'just' need to be implemented (for example __add__), or remapped to the original method
     calling them because on some built-in data types the magic method does not exist (for example, __getattr__ should
     not add __getattr__ to the stack but getattr)
     * All magic methods that do not work because the python framework does not allow them to return another type than
     the expected one. For all of them there are two methods: one in the class throwing an exception, and one at
     package-level to provide a replacement (The exception message provides the replacement method name).
    """

    # *** CASE 1 : magic methods that add themselves to the stack ***
    def __trunc__(self, *args):
        """ Returns a new _InputEvaluator performing '__trunc__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__trunc__', *args)

    def __next_in_mro__(self, *args):
        """ Returns a new _InputEvaluator performing '__next_in_mro__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__next_in_mro__', *args)

    def __rmod__(self, *args):
        """ Returns a new _InputEvaluator performing '__rmod__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rmod__', *args)

    def __tree_hash__(self, *args):
        """ Returns a new _InputEvaluator performing '__tree_hash__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__tree_hash__', *args)

    def __args__(self, *args):
        """ Returns a new _InputEvaluator performing '__args__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__args__', *args)

    def __lt__(self, *args):
        """ Returns a new _InputEvaluator performing '__lt__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__lt__', *args)

    def __floordiv__(self, *args):
        """ Returns a new _InputEvaluator performing '__floordiv__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__floordiv__', *args)

    def __gt__(self, *args):
        """ Returns a new _InputEvaluator performing '__gt__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__gt__', *args)

    def __orig_bases__(self, *args):
        """ Returns a new _InputEvaluator performing '__orig_bases__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__orig_bases__', *args)

    def __reversed__(self, *args):
        """ Returns a new _InputEvaluator performing '__reversed__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__reversed__', *args)

    def __ge__(self, *args):
        """ Returns a new _InputEvaluator performing '__ge__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__ge__', *args)

    def __getitem__(self, *args):
        """ Returns a new _InputEvaluator performing '__getitem__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__getitem__', *args)

    def __sub__(self, *args):
        """ Returns a new _InputEvaluator performing '__sub__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__sub__', *args)

    def __parameters__(self, *args):
        """ Returns a new _InputEvaluator performing '__parameters__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__parameters__', *args)

    def __mod__(self, *args):
        """ Returns a new _InputEvaluator performing '__mod__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__mod__', *args)

    def __invert__(self, *args):
        """ Returns a new _InputEvaluator performing '__invert__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__invert__', *args)

    def __origin__(self, *args):
        """ Returns a new _InputEvaluator performing '__origin__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__origin__', *args)

    def __rrshift__(self, *args):
        """ Returns a new _InputEvaluator performing '__rrshift__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rrshift__', *args)

    def __radd__(self, *args):
        """ Returns a new _InputEvaluator performing '__radd__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__radd__', *args)

    def __round__(self, *args):
        """ Returns a new _InputEvaluator performing '__round__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__round__', *args)

    def __next__(self, *args):
        """ Returns a new _InputEvaluator performing '__next__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__next__', *args)

    def __floor__(self, *args):
        """ Returns a new _InputEvaluator performing '__floor__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__floor__', *args)

    def __pow__(self, *args):
        """ Returns a new _InputEvaluator performing '__pow__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__pow__', *args)

    def __rtruediv__(self, *args):
        """ Returns a new _InputEvaluator performing '__rtruediv__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rtruediv__', *args)

    def __pos__(self, *args):
        """ Returns a new _InputEvaluator performing '__pos__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__pos__', *args)

    def __rshift__(self, *args):
        """ Returns a new _InputEvaluator performing '__rshift__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rshift__', *args)

    def __rdivmod__(self, *args):
        """ Returns a new _InputEvaluator performing '__rdivmod__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rdivmod__', *args)

    def __truediv__(self, *args):
        """ Returns a new _InputEvaluator performing '__truediv__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__truediv__', *args)

    def __divmod__(self, *args):
        """ Returns a new _InputEvaluator performing '__divmod__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__divmod__', *args)

    def __lshift__(self, *args):
        """ Returns a new _InputEvaluator performing '__lshift__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__lshift__', *args)

    def __extra__(self, *args):
        """ Returns a new _InputEvaluator performing '__extra__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__extra__', *args)

    def __eq__(self, *args):
        """ Returns a new _InputEvaluator performing '__eq__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__eq__', *args)

    def __mul__(self, *args):
        """ Returns a new _InputEvaluator performing '__mul__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__mul__', *args)

    def __coerce__(self, *args):
        """ Returns a new _InputEvaluator performing '__coerce__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__coerce__', *args)

    def __ceil__(self, *args):
        """ Returns a new _InputEvaluator performing '__ceil__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__ceil__', *args)

    def __rmul__(self, *args):
        """ Returns a new _InputEvaluator performing '__rmul__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rmul__', *args)

    def __call__(self, *args):
        """ Returns a new _InputEvaluator performing '__call__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__call__', *args)

    def __rsub__(self, *args):
        """ Returns a new _InputEvaluator performing '__rsub__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rsub__', *args)

    def __rfloordiv__(self, *args):
        """ Returns a new _InputEvaluator performing '__rfloordiv__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rfloordiv__', *args)

    def __neg__(self, *args):
        """ Returns a new _InputEvaluator performing '__neg__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__neg__', *args)

    def __le__(self, *args):
        """ Returns a new _InputEvaluator performing '__le__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__le__', *args)

    def __abs__(self, *args):
        """ Returns a new _InputEvaluator performing '__abs__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__abs__', *args)

    def __rpow__(self, *args):
        """ Returns a new _InputEvaluator performing '__rpow__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rpow__', *args)

    def __ne__(self, *args):
        """ Returns a new _InputEvaluator performing '__ne__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__ne__', *args)

    def __add__(self, *args):
        """ Returns a new _InputEvaluator performing '__add__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__add__', *args)

    def __rlshift__(self, *args):
        """ Returns a new _InputEvaluator performing '__rlshift__(x, *args)' on the result of this evaluator's evaluation """
        return self.add_bound_method_to_stack('__rlshift__', *args)



    # *** CASE 2 : magic methods that should raise an error and should be replaced with a module-level one ***
    def __format__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__format__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Format() method provided at valid8 package level instead')

    def __hash__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__hash__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Hash() method provided at valid8 package level instead')

    def __hex__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__hex__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Hex() method provided at valid8 package level instead')

    def __iter__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__iter__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Iter() method provided at valid8 package level instead')

    def __complex__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__complex__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Complex_() method provided at valid8 package level instead')

    def __len__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__len__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Len() method provided at valid8 package level instead')

    def __int__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__int__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Int() method provided at valid8 package level instead')

    def __repr__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__repr__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Repr() method provided at valid8 package level instead')

    def __bool__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__bool__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Bool() method provided at valid8 package level instead')

    def __float__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__float__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Float() method provided at valid8 package level instead')

    def __str__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__str__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Str() method provided at valid8 package level instead')

    def __sizeof__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__sizeof__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Getsizeof() method provided at valid8 package level instead')

    def __long__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__long__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Long() method provided at valid8 package level instead')

    def __bytes__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__bytes__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Bytes() method provided at valid8 package level instead')

    def __oct__(self, *args):
        """
        This magic method can not be used on an _InputEvaluator, because unfortunately python checks the
        result type and does not allow it to be a custom type.
        """
        raise NotImplementedError('__oct__ is not supported by _InputEvaluator, since python raises an'
                                  'error when its output is not directly an object of the type it expects.'
                                  'Please use the Oct() method provided at valid8 package level instead')



# *** CASE 2 second part: the package-level replacement methods
def Format(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__format__' magic method """
    return evaluator.add_bound_method_to_stack('__format__')


def Hash(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__hash__' magic method """
    return evaluator.add_bound_method_to_stack('__hash__')


def Hex(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__hex__' magic method """
    return evaluator.add_unbound_method_to_stack(hex)


def Iter(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__iter__' magic method """
    return evaluator.add_bound_method_to_stack('__iter__')


def Complex_(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__complex__' magic method """
    return evaluator.add_unbound_method_to_stack(complex)


def Len(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__len__' magic method """
    return evaluator.add_bound_method_to_stack('__len__')


def Int(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__int__' magic method """
    return evaluator.add_bound_method_to_stack('__int__')


def Repr(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__repr__' magic method """
    return evaluator.add_bound_method_to_stack('__repr__')


def Bool(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__bool__' magic method """
    return evaluator.add_bound_method_to_stack('__bool__')


def Float(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__float__' magic method """
    return evaluator.add_bound_method_to_stack('__float__')


def Str(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__str__' magic method """
    return evaluator.add_bound_method_to_stack('__str__')


def Getsizeof(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__sizeof__' magic method """
    return evaluator.add_bound_method_to_stack('__sizeof__')


def Long(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__long__' magic method """
    return evaluator.add_bound_method_to_stack('__long__')


def Bytes(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__bytes__' magic method """
    return evaluator.add_unbound_method_to_stack(bytes)


def Oct(evaluator: _InputEvaluatorGenerated):
    """ This is a replacement method for _InputEvaluator '__oct__' magic method """
    return evaluator.add_unbound_method_to_stack(oct)



