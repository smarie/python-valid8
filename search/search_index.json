{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python-validate (valid8) \u00b6 \"valid8ing is not a crime\" ;-) Major API changes in version 5.0.0 . See changelog for details. Overview \u00b6 valid8 provides user-friendly tools for 3 kind of \"entry points\": general-purpose inline validation (=anywhere in your code), function inputs/outputs validation class fields validation. All these entry points raise consistent ValidationError including user-friendly details, with inheritance of ValueError / TypeError as appropriate. You can customize this error so as to get unique error types convenient for i18n. Now what can you validate ? Pretty much anything: you define validators by combining one or several elementary validation functions, with minimalistic requirements . For this you can reuse built-in functions , 3d party functions, or write your own. You can even augment existing functions with more user-friendly errors. The internal composition framework makes it easy to combine the best of all worlds for each situation. So with a bird eye's view: Do I need validation ? \u00b6 type ( TypeError ) and value ( ValueError ) validation is key to smooth user experience: if something fails, there is nothing more frustrating that a horrible cryptic error message. Good validation leads to less end-user frustration. So validation has to be done in user-facing production code. However it is maybe already done by someone else: if your code is inside a framework that does the final application for you ( django , click , fastAPI etc.), user inputs are probably already validated. So validation in your code is optional (but can help) . if your code is a low-level library and you do not care about the final application, validation is also optional (but it can help) . Your library's documentation may replace the need for validation to some extend. otherwise validation becomes quite recommended (you care about the final application 's user experience, and no application framework handles it already for you) In this page , we try to explain what is validation, what you would need to do in order to implement it correctly and consistently by yourself ( assert is not a viable solution unfortunately), and demonstrate how much effort that would cost you . I searched and found tons of good and less good libraries out there , but did not find any that would provide a somehow generic answer covering 80% of the needs - especially the particular needs I had for class attributes validation in autoclass , attrs and now in pyfields . valid8 provides tools to perform validation in a minimum number of lines and with built-in consistency, so that it hopefully becomes fun and easy to include in your code. Installing \u00b6 > pip install valid8 Optional but recommended: If you wish to create highly compact object classes with field type+value validation, have a look at pyfields , attrs or autoclass . If you wish to define your own validation functions for functions and classes validation in a very compact way, you may wish to also install mini_lambda . See below for examples. 0. Concepts \u00b6 valid8 relies on two main concepts: entry points are responsible to apply validation to a specific part of your code. They all raise ValidationError when validation failed, and are the ones providing the context (they know that the variable is a function input or a class field, and know its name) validation functions are in charge of the validation per se . They receive the value to validate and should return True or None in case of success. Each entry point has a single main underlying validation function, automatically created from all the user-provided functions using the simple validation function definition syntax . 1. Entry points \u00b6 a - inline \u00b6 valid8 provides two validation methods that you may use anywhere in your code: validate(...) to perform the most simple validation tasks in one line of code with validation(...) (or its alias with validator(...) as v ) for any other validation task, in two or more lines of code validate \u00b6 The validate method is the most straightforward tool in this toolbox. It provides you with ways to quickly validate one or several of: value is not None value is an instance of one type in a reference set, or is a subtype of a reference set value equals a reference item, value is contained in a set, contains a reference item, or is a sub/superset of a reference set value is greater/smaller than a reference (strict or not) value length is fixed, or is greater/smaller than a reference. one or several other validation functions (custom, 3d party) For example: from valid8 import validate surf = - 1 validate ( 'surface' , surf , instance_of = int , min_value = 0 ) results in ValidationError [ ValueError ] : Error validating [ surface = -1 ] . \\ TooSmall: x > = 0 does not hold for x = -1. Wrong value: -1. Note that the resulting exception object contains much of the available information ( var_name , var_value , failure ) as fields. All functions from the built-in validation library are supported as explicit arguments as shown above, so that the method execution is the fastest possible. In addition you can add any other validation function with the custom argument: from mini_lambda import x surf = 20 validate ( 'surface' , surf , instance_of = int , min_value = 0 , custom = [ x ** 2 < 50 ]) yields ValidationError[ValueError]: Error validating [surface=20]: \\ validation function [x ** 2 < 50] returned [False]. Here the custom validation function is implemented using mini-lambda , but any function will do ; the only requirement is that your function accepts one positional input and returns True or None in case of success. You can easily define custom validation functions with composition, custom failure messages or even custom failure types. For example these are accepted: # custom failure message validate ( 'surface' , surf , instance_of = int , min_value = 0 , custom = [( x ** 2 < 50 , 'x should be fairly small' )]) # composition with detailed failure messages validate ( 'surface' , surf , instance_of = int , custom = { 'x should be fairly small' : x ** 2 < 50 , 'x should be a multiple of 3' : x % 3 == 0 }) See API reference for usage details, and below validation functions and validation errors to explore the various customization possibilities. validator / validation \u00b6 The validator (alias validation ) context manager allows you to define the validation procedure yourself, with any statement or function of your choice. If you rely on functions that output a boolean flag indicating success ( \"boolean testers\" ), you simply have to plug that flag on the object provided by the context manager, as shown below: from valid8 import validator surf = - 1 with validator ( 'surface' , surf ) as v : v . alid = surf > 0 Which yields ValidationError [ ValueError ] : Error validating [ surface = -1 ] : \\ validation function [ v.alid = surf > 0 ] returned [ False ] . Note that the text of the error displays the source code that led to that failure. If you rely on functions that may raise exceptions ( \"failure raisers\" ), validator will catch them and append them as the inner failure of the resulting ValidationError : from math import isfinite surf = 1j with validator ( 'surface' , surf ) as v : v . alid = surf > 0 and isfinite ( surf ) yields ValidationError [ TypeError ] : Error validating [ surface = 1j ] . \\ InvalidType: Function [ v.alid = surf > 0 and isfinite ( surf )] raised \\ TypeError: '>' not supported between instances of 'complex' and 'int' . With validator you are therefore guaranteed that any exception happening in the inner code block will be caught and turned into a friendly ValidationError , whatever the cause ( None handling, known validation failures, unknown other errors). You therefore do not have to write the usual if/else/try/except wrappers to handle all cases. A couple important things to note: the field name where you put the boolean flag does not matter, so if you prefer you can use alternate naming such as with validator(...) as r: and then r.esults = there is no need to feed any result to the validator. If you rely on failure raiser -style base functions, for example a check_uniform_sampling or an assert_series_equal , you can just call them and the wrapper will assume that no exception means success. In such case the validation alias might make more sense in terms of readability: with validation ( 'dataframe' , df , instance_of = pd . DataFrame ): check_uniform_sampling ( df ) assert_series_equal ( df [ 'a' ], ref_series ) Note on type checking with isinstance Although you can use the built-in isinstance method inside your validation code block, if you do it valid8 will not be able to distinguish between TypeError and ValueError . Instead, please consider either using the instance_of parameter of validation : with validator ( 'surface' , surf , instance_of = int ) as v : v . alid = surf > 0 or using the assert_instance_of validation method provided for this purpose: from valid8 import assert_instance_of , assert_subclass_of with validator ( 'surface' , surf ) as v : assert_instance_of ( surf , int ) v . alid = surf > 0 See API reference for usage details, and below validation functions and custom exceptions to explore the various customization possibilities. b - functions \u00b6 The @validate_arg decorator adds input validation to a function. Here is an example where we decorate a build_house function: from mini_lambda import s , Len from valid8 import validate_arg from valid8.validation_lib import instance_of @validate_arg ( 'name' , instance_of ( str ), Len ( s ) > 0 , help_msg = 'name should be a non-empty string' ) def build_house ( name , surface = None ): print ( 'Building house... DONE !' ) return name , surface As you can see above, any number of base validation functions can be provided to the decorator - this will correspond to an implicit and_ being performed, equivalent to one that you would have done with the built-in composition framework . Here we validate the input argument name by chaining the function instance_of(str) (from the built-in validation functions library ) with a custom lambda function Len(s) > 0 created using the mini_lambda syntax. Let's try it: > build_house ( 'sweet home' , 200 ) # Valid > build_house ( '' , 200 ) InputValidationError [ ValueError ] : name should be a non-empty string. \\ Error validating input [ name = '' ] for function [ build_house ] . \\ At least one validation function failed for value '' . \\ Successes: [ \"instance_of_<class 'str'>\" ] \\ / Failures: { 'len(s) > 0' : 'Returned False.' } . We can see in this verbose exception all details of interest: first the custom help_msg ; then the validated function and input name; and finally the composition failure resulting from one of the two base functions failing ( len(s) > 0 as stated). Note that since Len is mini_lambda 's equivalent of len , the string representation is lowercase The @validate_out function decorator works the same way for output validation, except that you don't provide it with any name. nonable inputs/outputs \u00b6 Here is a more complete example with both input and output validation: from mini_lambda import s , x , l , Len from valid8 import validate_arg , validate_out from valid8.validation_lib import instance_of , is_multiple_of @validate_arg ( 'name' , instance_of ( str ), Len ( s ) > 0 , help_msg = 'name should be a non-empty string' ) @validate_arg ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), help_msg = 'Surface should be a multiple of 100 between 0 and 10000.' ) @validate_out ( instance_of ( tuple ), Len ( l ) == 2 ) def build_house ( name , surface = None ): print ( 'Building house... DONE !' ) return name , surface Something surprising happens: > build_house ( None ) InputValidationError [ TypeError ] : name should be a non-empty string. \\ Error validating input [ name = None ] ... > build_house ( 'sweet home' ) # No error ! > build_house ( 'sweet home' , None ) # No error ! No error is raised when surface is None , while our base validation functions should both fail in presence of None : > is_multiple_of ( 100 )( None ) TypeError: unsupported operand type ( s ) for %: 'NoneType' and 'int' > ( Len ( s ) > 0 ) .evaluate ( None ) TypeError: object of type 'NoneType' has no len () Indeed, by default None values have a special validation procedure depending on the function signature: if the input to validate has a default value of None it is considered nonable . For this input, None values will not enter the validation procedure, and be sent directly to the function. In other words validation is skipped for None . The same principle goes for inputs and outputs that have a PEP484 Optional[...] type hint, with or without default value. in the absence of None default value or Optional[...] type hint, the input or output is considered normal . None values will be send to the validation function as usual, as it would be for non- None values The default behaviour described above may not suit your needs, and can be changed by changing the none_policy keyword argument. Valid values are: NonePolicy.SKIP_IF_NONABLE_ELSE_VALIDATE : the default behaviour described above NonePolicy.SKIP_IF_NONABLE_ELSE_FAIL : same than the above, except that for normal inputs and outputs, None values will be rejected automatically - no need to test for None in your validation function. NonePolicy.SKIP : validation will always be skipped for None values NonePolicy.FAIL : validation will always fail for None values NonePolicy.VALIDATE : validation will always be performed even for None values See API reference for usage details, and below validation functions and custom exceptions to explore the various customization possibilities. c - class fields \u00b6 If you use pyfields to define your classes, valid8 is already embedded in the field() method: you should rather look here . Otherwise (for normal classes or classes with attrs , autoclass ...) continue reading. The @validate_field decorator adds field validation to a class. It is able to validate a field if the field is: a descriptor - in which case it is equivalent to a @validate_arg added on the __set__ function of the descriptor, but with a more user-friendly error message a property , in which case it is equivalent to a @validate_arg added on the fset function of the descriptor, but with a more user-friendly error message. or a constructor input , in which case it is equivalent to a @validate_arg added on the constructor. In such case WARNING validation will only be called at initial object creation, not at subsequent field modifications! Here is an example where we add validation to a House class with two fields: from valid8 import validate_field from valid8.validation_lib import instance_of , is_multiple_of from mini_lambda import x , s , Len @validate_field ( 'name' , instance_of ( str ), Len ( s ) > 0 , help_msg = 'name should be a non-empty string' ) @validate_field ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), help_msg = 'Surface should be a multiple of100 between 0 and 10000' ) class House : def __init__ ( self , name , surface = None ): self . name = name self . surface = surface @property def surface ( self ): return self . __surface @surface.setter def surface ( self , surface = None ): self . __surface = surface Let's try it: > h = House ( 'sweet home' ) # valid > h = House ( '' ) ClassFieldValidationError [ ValueError ] : name should be a non-empty string. \\ Error validating field [ name =] for class [ House ] . \\ At least one validation function failed for value '' . \\ Successes: [ \"instance_of_<class 'str'>\" ] / Failures: { 'len(s) > 0' : 'False' } > h.surface = 10000 ClassFieldValidationError [ ValueError ] : Surface should be a multiple of 100 between 0 and 10000 Error validating field [ surface = 10000 ] for class [ House ] . \\ At least one validation function failed for value 10000 . \\ Successes: [ 'is_multiple_of_100' ] \\ / Failures: { '(x >= 0) & (x < 10000)' : 'False' } . > h.name = '' # WARNING: does not raise ValidationError (no setter!) For classes using attrs or autoclass , it works too . As for functions, the default none policy is SKIP_IF_NONABLE_ELSE_VALIDATE but can be changed similarly to what we described in previous section See API reference for usage details, and below validation functions and custom exceptions to explore the various customization possibilities. 2. Validation functions \u00b6 We have seen above that all entry point validators (inline, function, class) provide a way for you to declare custom validation functions to use. Here are the resources that will get you started: in validation function basics you will learn what is required to integrate any function, and how to improve existing functions you can browse the bundled validation functions library to find some common functions to reuse as we already saw above, the mini_lambda syntax can be used to define some validation functions inline (such as x > 0 ) without writing lambda x: . make sure that you check the simple definition syntax . With it you will be able to easily define advanced validation functions. the bundled composition functions can optionally be used to create more complex combinations than \"and\". 3. Custom exceptions \u00b6 Various options are provided to customize the raised exception. These options are available on all entry points: both on validate , validator / validation , @validate_arg , @validate_out , @validate_io and @validate_field . a - custom message \u00b6 You can specify a custom error message that will be displayed at the beginning of the default message: from valid8 import validation with validation ( 'surface' , surf , help_msg = \"Surface should be a finite positive integer\" ) as v : v . alid = surf > 0 and isfinite ( surf ) yields for surf = -1 ValidationError [ ValueError ] : Surface should be a finite positive integer. \\ Error validating [ surface = -1 ] : \\ validation function [ v.alid = surf > 0 and isfinite ( surf )] returned [ False ] . b - custom type \u00b6 Or even better, a custom error type, which is a good practice to ease internationalization (unique applicative error codes). The base ValidationError class provides default behaviours allowing you to define subclasses in a quite compact form: from valid8 import ValidationError , validate class InvalidSurface ( ValidationError ): help_msg = 'Surface should be a positive integer' validate ( 'surface' , surf , instance_of = int , min_value = 0 , error_type = InvalidSurface ) yields for surf = -1 InvalidSurface [ ValueError ] : Surface should be a positive integer. \\ Error validating [ surface = -1 ] . \\ TooSmall: x > = 0 does not hold for x = -1. Wrong value: -1. Note that for function entry points, the custom type should inherit from InputValidationError or OutputValidationError respectively. For class entry points, the custom type should inherit from ClassFieldValidationError . c - message templating \u00b6 Finally, the help_msg field acts as a string template that will receive any additional keyword argument thrown at the validation method. So you can define reusable error classes without too much hassle: class InvalidSurface ( ValidationError ): help_msg = 'Surface should be > {minimum}, found {var_value}' validate ( 'surface' , surf , instance_of = int , min_value = 0 , error_type = InvalidSurface , minimum = 0 ) yields InvalidSurface [ ValueError ] : Surface should be > 0 , found -1. \\ Error validating [ surface = -1 ] . \\ TooSmall: x > = 0 does not hold for x = -1. Wrong value: -1. Note: as shown in that last example, the value being validated is already sent to the help message string to format under the 'var_value' key, so you do not need to pass it. Obviously you can further customize your exception subclasses if you wish. d - TypeError or ValueError \u00b6 ValidationError does not by default inherit from TypeError or ValueError , because in the general case, valid8 has no means of knowing. But you may have noticed in all of the output message examples shown above that one of the two is still appearing each time in the resulting exception. This is because valid8 automatically guesses: when a validation error happens, it recursively looks at the type of the failure cause for a TypeError or ValueError (default if nothing is found). It then dynamically creates an appropriate exception type inheriting both from ValidationError and from either TypeError or ValueError according to what has been found. This dynamic type is cached for speed considerations. It has some custom display methods that make it appear as follows: > validate ( 'surface' , -1, instance_of = int, min_value = 0 ) ValidationError [ ValueError ] > validate ( 'surface' , 1j, instance_of = int, min_value = 0 ) ValidationError [ TypeError ] If you do not wish the automatic guessing to happen, you can always declare the inheritance explicitly by creating custom subclasses inheriting from the one of your choice, or both: class InvalidSurface ( ValidationError , ValueError ): help_msg = \"\" If you create a custom subclass but do not inherit from TypeError nor ValueError , the automatic guessing will take place as usual. Main features \u00b6 Separation of validation intent (entry points validate , validator , @validate_arg ...) from validation means (base validation code / functions). Entry points provide a clear and consistent behaviour matching your applicative intent, hiding the diversity of base validation functions that you rely on to do it. Clear entry points to serve most common needs related with validation: Inline validation : two functions validate and validator / validation to perform validation anywhere in your code. Function validation : two decorators @validate_arg and @validate_out , as well as a more limited @validate_io , to add input and output validation to any function. A manual decorator decorate_with_validation provides the same functionality for retrofit purposes. Class validation : one decorator @validate_field to add validation to class fields. Consistent behaviour : all defensive mode entry points provide the same behaviour, raising subclasses of ValidationError in case of failure, whatever the diversity of failure modes that can happen in base validation code. The exception object contains all contextual information in its fields so as to be easily usable by a global exception handler at application-level, for example for internationalization. Moreover, the appropriate TypeError or ValueError base class is dynamically added to the resulting exception type if not present already. Consistency is also ensured by the fact that all entry points rely on a common Validator class. Highly customizable : all entry points can be customized so as to fit your application needs. In particular you probably do not want users to see valid8 exceptions and messages, but rather your exceptions and messages. This is easy to do with the two help_msg and error_type options. python-first, not schema-first . This library is intended to provide validation anywhere in your code, not only when data enters a web service, a CLI or a form. There already are libs out there for that purpose. valid8 is rather meant to be as simple as possible and as open as possible to any kind of validation, even those that can not easily be described in a schema. Separation of value validation from type validation is possible . valid8 can be combined with any PEP484-based type validation library such as enforce or pytypes . Plays well with pyfields , autoclass and attrs . Declare validation once by annotating the class with @validate_field , and you're good to go! validation functions Compliant with most base validation functions out there . You may use base validation functions from anywhere including your own, and including functools.partial , lambda or even callable objects implementing the __call__ magic method. The only requirement is that they return True or None in case of success ! The way they fail is not important, valid8 tolerates all. If you wish to create your own, you can leverage the three exception classes provided. Built-in library of base validation functions , by object type. Do not hesitate to contribute! Also, do not hesitate to rely on other libraries for dedicated object types such as these , or to build your own ! Built-in support for mini_lambda to define base validation functions for the decorators, so that you do not need to write lambda x: everywhere, and the failure messages are far more easy to read. Besides the global error customization as well as built-in syntax for failure raiser definition allows you to easily add exception details to lambda expressions. Built-in composition framework . Built-in functions and_ , or_ , xor_ , not_ , not_all , failure_raiser , skip_on_none and fail_on_none allow you to quickly create complex validation functions by reusing simpler ones, if you do not want to do it using lambda or mini_lambda . In particular, and_ is implicitly used if you provide a list of base validation functions to any of the valid8 decorators. Other Validation libraries \u00b6 Many validation libraries are available on PyPI already. The following list is by far not exhaustive, but gives an overview. Do not hesitate to contribute to this list with a pull request! Origin of this project \u00b6 When it all started, I was just looking for a library providing a @validate annotation with a basic library of validators and some logic to associate them, so as to complete autoclass . I searched and found tons of good and less good libraries out there . However none of them was really a good fit for autoclass , for diverse reasons: only a few of them were available as decorators many of them were strongly mixing type validation and value validation, which is not necessary anymore thanks to PEP484. This was making the autoclass examples more confusing. only a few of them were providing a simple yet consistent and reusable framework to deal with validation functions, combine them, etc. And the good ones were based on defining a Schema first, which seemed a bit 'too much' for me already. finally, none of them was really encouraging the community to collaborate by displaying a catalog of base validation functions per data type, open to contributions. So I first created the @validate goodie in autoclass . When the project became more mature, I decided to extract it and make it independent, so that maybe the community will find it interesting. When this project grew, I found that its embedded library of base validation functions was not flexible enough to cover a large variety of use cases, and will probably never be even if we try our best, so I came up with the complementary mini_lambda syntax which is now an independent project, typically used when your base validation function is very specific, but yet quite simple to write in plain python. Later on I decided to create a better alternative to autoclass , named pyfields . This challenged the valid8 project once again to be simple, clear, and extensible. This gave version 5.0.0 . See Also \u00b6 We had this discussion on python-ideas to suggest a validate statement, functional equivalent of assert_valid , that would be built-in the python syntax so as to reduce parenthesis. An issue was also created. Julien Danjou's Definitive Guide to Python Exceptions . It was of great inspiration and help to design valid8 's exception hierarchy. Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-valid8","title":"Home and usage"},{"location":"#python-validate-valid8","text":"\"valid8ing is not a crime\" ;-) Major API changes in version 5.0.0 . See changelog for details.","title":"python-validate (valid8)"},{"location":"#overview","text":"valid8 provides user-friendly tools for 3 kind of \"entry points\": general-purpose inline validation (=anywhere in your code), function inputs/outputs validation class fields validation. All these entry points raise consistent ValidationError including user-friendly details, with inheritance of ValueError / TypeError as appropriate. You can customize this error so as to get unique error types convenient for i18n. Now what can you validate ? Pretty much anything: you define validators by combining one or several elementary validation functions, with minimalistic requirements . For this you can reuse built-in functions , 3d party functions, or write your own. You can even augment existing functions with more user-friendly errors. The internal composition framework makes it easy to combine the best of all worlds for each situation. So with a bird eye's view:","title":"Overview"},{"location":"#do-i-need-validation","text":"type ( TypeError ) and value ( ValueError ) validation is key to smooth user experience: if something fails, there is nothing more frustrating that a horrible cryptic error message. Good validation leads to less end-user frustration. So validation has to be done in user-facing production code. However it is maybe already done by someone else: if your code is inside a framework that does the final application for you ( django , click , fastAPI etc.), user inputs are probably already validated. So validation in your code is optional (but can help) . if your code is a low-level library and you do not care about the final application, validation is also optional (but it can help) . Your library's documentation may replace the need for validation to some extend. otherwise validation becomes quite recommended (you care about the final application 's user experience, and no application framework handles it already for you) In this page , we try to explain what is validation, what you would need to do in order to implement it correctly and consistently by yourself ( assert is not a viable solution unfortunately), and demonstrate how much effort that would cost you . I searched and found tons of good and less good libraries out there , but did not find any that would provide a somehow generic answer covering 80% of the needs - especially the particular needs I had for class attributes validation in autoclass , attrs and now in pyfields . valid8 provides tools to perform validation in a minimum number of lines and with built-in consistency, so that it hopefully becomes fun and easy to include in your code.","title":"Do I need validation ?"},{"location":"#installing","text":"> pip install valid8 Optional but recommended: If you wish to create highly compact object classes with field type+value validation, have a look at pyfields , attrs or autoclass . If you wish to define your own validation functions for functions and classes validation in a very compact way, you may wish to also install mini_lambda . See below for examples.","title":"Installing"},{"location":"#0-concepts","text":"valid8 relies on two main concepts: entry points are responsible to apply validation to a specific part of your code. They all raise ValidationError when validation failed, and are the ones providing the context (they know that the variable is a function input or a class field, and know its name) validation functions are in charge of the validation per se . They receive the value to validate and should return True or None in case of success. Each entry point has a single main underlying validation function, automatically created from all the user-provided functions using the simple validation function definition syntax .","title":"0. Concepts"},{"location":"#1-entry-points","text":"","title":"1. Entry points"},{"location":"#a-inline","text":"valid8 provides two validation methods that you may use anywhere in your code: validate(...) to perform the most simple validation tasks in one line of code with validation(...) (or its alias with validator(...) as v ) for any other validation task, in two or more lines of code","title":"a - inline"},{"location":"#validate","text":"The validate method is the most straightforward tool in this toolbox. It provides you with ways to quickly validate one or several of: value is not None value is an instance of one type in a reference set, or is a subtype of a reference set value equals a reference item, value is contained in a set, contains a reference item, or is a sub/superset of a reference set value is greater/smaller than a reference (strict or not) value length is fixed, or is greater/smaller than a reference. one or several other validation functions (custom, 3d party) For example: from valid8 import validate surf = - 1 validate ( 'surface' , surf , instance_of = int , min_value = 0 ) results in ValidationError [ ValueError ] : Error validating [ surface = -1 ] . \\ TooSmall: x > = 0 does not hold for x = -1. Wrong value: -1. Note that the resulting exception object contains much of the available information ( var_name , var_value , failure ) as fields. All functions from the built-in validation library are supported as explicit arguments as shown above, so that the method execution is the fastest possible. In addition you can add any other validation function with the custom argument: from mini_lambda import x surf = 20 validate ( 'surface' , surf , instance_of = int , min_value = 0 , custom = [ x ** 2 < 50 ]) yields ValidationError[ValueError]: Error validating [surface=20]: \\ validation function [x ** 2 < 50] returned [False]. Here the custom validation function is implemented using mini-lambda , but any function will do ; the only requirement is that your function accepts one positional input and returns True or None in case of success. You can easily define custom validation functions with composition, custom failure messages or even custom failure types. For example these are accepted: # custom failure message validate ( 'surface' , surf , instance_of = int , min_value = 0 , custom = [( x ** 2 < 50 , 'x should be fairly small' )]) # composition with detailed failure messages validate ( 'surface' , surf , instance_of = int , custom = { 'x should be fairly small' : x ** 2 < 50 , 'x should be a multiple of 3' : x % 3 == 0 }) See API reference for usage details, and below validation functions and validation errors to explore the various customization possibilities.","title":"validate"},{"location":"#validatorvalidation","text":"The validator (alias validation ) context manager allows you to define the validation procedure yourself, with any statement or function of your choice. If you rely on functions that output a boolean flag indicating success ( \"boolean testers\" ), you simply have to plug that flag on the object provided by the context manager, as shown below: from valid8 import validator surf = - 1 with validator ( 'surface' , surf ) as v : v . alid = surf > 0 Which yields ValidationError [ ValueError ] : Error validating [ surface = -1 ] : \\ validation function [ v.alid = surf > 0 ] returned [ False ] . Note that the text of the error displays the source code that led to that failure. If you rely on functions that may raise exceptions ( \"failure raisers\" ), validator will catch them and append them as the inner failure of the resulting ValidationError : from math import isfinite surf = 1j with validator ( 'surface' , surf ) as v : v . alid = surf > 0 and isfinite ( surf ) yields ValidationError [ TypeError ] : Error validating [ surface = 1j ] . \\ InvalidType: Function [ v.alid = surf > 0 and isfinite ( surf )] raised \\ TypeError: '>' not supported between instances of 'complex' and 'int' . With validator you are therefore guaranteed that any exception happening in the inner code block will be caught and turned into a friendly ValidationError , whatever the cause ( None handling, known validation failures, unknown other errors). You therefore do not have to write the usual if/else/try/except wrappers to handle all cases. A couple important things to note: the field name where you put the boolean flag does not matter, so if you prefer you can use alternate naming such as with validator(...) as r: and then r.esults = there is no need to feed any result to the validator. If you rely on failure raiser -style base functions, for example a check_uniform_sampling or an assert_series_equal , you can just call them and the wrapper will assume that no exception means success. In such case the validation alias might make more sense in terms of readability: with validation ( 'dataframe' , df , instance_of = pd . DataFrame ): check_uniform_sampling ( df ) assert_series_equal ( df [ 'a' ], ref_series ) Note on type checking with isinstance Although you can use the built-in isinstance method inside your validation code block, if you do it valid8 will not be able to distinguish between TypeError and ValueError . Instead, please consider either using the instance_of parameter of validation : with validator ( 'surface' , surf , instance_of = int ) as v : v . alid = surf > 0 or using the assert_instance_of validation method provided for this purpose: from valid8 import assert_instance_of , assert_subclass_of with validator ( 'surface' , surf ) as v : assert_instance_of ( surf , int ) v . alid = surf > 0 See API reference for usage details, and below validation functions and custom exceptions to explore the various customization possibilities.","title":"validator/validation"},{"location":"#b-functions","text":"The @validate_arg decorator adds input validation to a function. Here is an example where we decorate a build_house function: from mini_lambda import s , Len from valid8 import validate_arg from valid8.validation_lib import instance_of @validate_arg ( 'name' , instance_of ( str ), Len ( s ) > 0 , help_msg = 'name should be a non-empty string' ) def build_house ( name , surface = None ): print ( 'Building house... DONE !' ) return name , surface As you can see above, any number of base validation functions can be provided to the decorator - this will correspond to an implicit and_ being performed, equivalent to one that you would have done with the built-in composition framework . Here we validate the input argument name by chaining the function instance_of(str) (from the built-in validation functions library ) with a custom lambda function Len(s) > 0 created using the mini_lambda syntax. Let's try it: > build_house ( 'sweet home' , 200 ) # Valid > build_house ( '' , 200 ) InputValidationError [ ValueError ] : name should be a non-empty string. \\ Error validating input [ name = '' ] for function [ build_house ] . \\ At least one validation function failed for value '' . \\ Successes: [ \"instance_of_<class 'str'>\" ] \\ / Failures: { 'len(s) > 0' : 'Returned False.' } . We can see in this verbose exception all details of interest: first the custom help_msg ; then the validated function and input name; and finally the composition failure resulting from one of the two base functions failing ( len(s) > 0 as stated). Note that since Len is mini_lambda 's equivalent of len , the string representation is lowercase The @validate_out function decorator works the same way for output validation, except that you don't provide it with any name.","title":"b - functions"},{"location":"#nonable-inputsoutputs","text":"Here is a more complete example with both input and output validation: from mini_lambda import s , x , l , Len from valid8 import validate_arg , validate_out from valid8.validation_lib import instance_of , is_multiple_of @validate_arg ( 'name' , instance_of ( str ), Len ( s ) > 0 , help_msg = 'name should be a non-empty string' ) @validate_arg ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), help_msg = 'Surface should be a multiple of 100 between 0 and 10000.' ) @validate_out ( instance_of ( tuple ), Len ( l ) == 2 ) def build_house ( name , surface = None ): print ( 'Building house... DONE !' ) return name , surface Something surprising happens: > build_house ( None ) InputValidationError [ TypeError ] : name should be a non-empty string. \\ Error validating input [ name = None ] ... > build_house ( 'sweet home' ) # No error ! > build_house ( 'sweet home' , None ) # No error ! No error is raised when surface is None , while our base validation functions should both fail in presence of None : > is_multiple_of ( 100 )( None ) TypeError: unsupported operand type ( s ) for %: 'NoneType' and 'int' > ( Len ( s ) > 0 ) .evaluate ( None ) TypeError: object of type 'NoneType' has no len () Indeed, by default None values have a special validation procedure depending on the function signature: if the input to validate has a default value of None it is considered nonable . For this input, None values will not enter the validation procedure, and be sent directly to the function. In other words validation is skipped for None . The same principle goes for inputs and outputs that have a PEP484 Optional[...] type hint, with or without default value. in the absence of None default value or Optional[...] type hint, the input or output is considered normal . None values will be send to the validation function as usual, as it would be for non- None values The default behaviour described above may not suit your needs, and can be changed by changing the none_policy keyword argument. Valid values are: NonePolicy.SKIP_IF_NONABLE_ELSE_VALIDATE : the default behaviour described above NonePolicy.SKIP_IF_NONABLE_ELSE_FAIL : same than the above, except that for normal inputs and outputs, None values will be rejected automatically - no need to test for None in your validation function. NonePolicy.SKIP : validation will always be skipped for None values NonePolicy.FAIL : validation will always fail for None values NonePolicy.VALIDATE : validation will always be performed even for None values See API reference for usage details, and below validation functions and custom exceptions to explore the various customization possibilities.","title":"nonable inputs/outputs"},{"location":"#c-class-fields","text":"If you use pyfields to define your classes, valid8 is already embedded in the field() method: you should rather look here . Otherwise (for normal classes or classes with attrs , autoclass ...) continue reading. The @validate_field decorator adds field validation to a class. It is able to validate a field if the field is: a descriptor - in which case it is equivalent to a @validate_arg added on the __set__ function of the descriptor, but with a more user-friendly error message a property , in which case it is equivalent to a @validate_arg added on the fset function of the descriptor, but with a more user-friendly error message. or a constructor input , in which case it is equivalent to a @validate_arg added on the constructor. In such case WARNING validation will only be called at initial object creation, not at subsequent field modifications! Here is an example where we add validation to a House class with two fields: from valid8 import validate_field from valid8.validation_lib import instance_of , is_multiple_of from mini_lambda import x , s , Len @validate_field ( 'name' , instance_of ( str ), Len ( s ) > 0 , help_msg = 'name should be a non-empty string' ) @validate_field ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), help_msg = 'Surface should be a multiple of100 between 0 and 10000' ) class House : def __init__ ( self , name , surface = None ): self . name = name self . surface = surface @property def surface ( self ): return self . __surface @surface.setter def surface ( self , surface = None ): self . __surface = surface Let's try it: > h = House ( 'sweet home' ) # valid > h = House ( '' ) ClassFieldValidationError [ ValueError ] : name should be a non-empty string. \\ Error validating field [ name =] for class [ House ] . \\ At least one validation function failed for value '' . \\ Successes: [ \"instance_of_<class 'str'>\" ] / Failures: { 'len(s) > 0' : 'False' } > h.surface = 10000 ClassFieldValidationError [ ValueError ] : Surface should be a multiple of 100 between 0 and 10000 Error validating field [ surface = 10000 ] for class [ House ] . \\ At least one validation function failed for value 10000 . \\ Successes: [ 'is_multiple_of_100' ] \\ / Failures: { '(x >= 0) & (x < 10000)' : 'False' } . > h.name = '' # WARNING: does not raise ValidationError (no setter!) For classes using attrs or autoclass , it works too . As for functions, the default none policy is SKIP_IF_NONABLE_ELSE_VALIDATE but can be changed similarly to what we described in previous section See API reference for usage details, and below validation functions and custom exceptions to explore the various customization possibilities.","title":"c - class fields"},{"location":"#2-validation-functions","text":"We have seen above that all entry point validators (inline, function, class) provide a way for you to declare custom validation functions to use. Here are the resources that will get you started: in validation function basics you will learn what is required to integrate any function, and how to improve existing functions you can browse the bundled validation functions library to find some common functions to reuse as we already saw above, the mini_lambda syntax can be used to define some validation functions inline (such as x > 0 ) without writing lambda x: . make sure that you check the simple definition syntax . With it you will be able to easily define advanced validation functions. the bundled composition functions can optionally be used to create more complex combinations than \"and\".","title":"2. Validation functions"},{"location":"#3-custom-exceptions","text":"Various options are provided to customize the raised exception. These options are available on all entry points: both on validate , validator / validation , @validate_arg , @validate_out , @validate_io and @validate_field .","title":"3. Custom exceptions"},{"location":"#a-custom-message","text":"You can specify a custom error message that will be displayed at the beginning of the default message: from valid8 import validation with validation ( 'surface' , surf , help_msg = \"Surface should be a finite positive integer\" ) as v : v . alid = surf > 0 and isfinite ( surf ) yields for surf = -1 ValidationError [ ValueError ] : Surface should be a finite positive integer. \\ Error validating [ surface = -1 ] : \\ validation function [ v.alid = surf > 0 and isfinite ( surf )] returned [ False ] .","title":"a - custom message"},{"location":"#b-custom-type","text":"Or even better, a custom error type, which is a good practice to ease internationalization (unique applicative error codes). The base ValidationError class provides default behaviours allowing you to define subclasses in a quite compact form: from valid8 import ValidationError , validate class InvalidSurface ( ValidationError ): help_msg = 'Surface should be a positive integer' validate ( 'surface' , surf , instance_of = int , min_value = 0 , error_type = InvalidSurface ) yields for surf = -1 InvalidSurface [ ValueError ] : Surface should be a positive integer. \\ Error validating [ surface = -1 ] . \\ TooSmall: x > = 0 does not hold for x = -1. Wrong value: -1. Note that for function entry points, the custom type should inherit from InputValidationError or OutputValidationError respectively. For class entry points, the custom type should inherit from ClassFieldValidationError .","title":"b - custom type"},{"location":"#c-message-templating","text":"Finally, the help_msg field acts as a string template that will receive any additional keyword argument thrown at the validation method. So you can define reusable error classes without too much hassle: class InvalidSurface ( ValidationError ): help_msg = 'Surface should be > {minimum}, found {var_value}' validate ( 'surface' , surf , instance_of = int , min_value = 0 , error_type = InvalidSurface , minimum = 0 ) yields InvalidSurface [ ValueError ] : Surface should be > 0 , found -1. \\ Error validating [ surface = -1 ] . \\ TooSmall: x > = 0 does not hold for x = -1. Wrong value: -1. Note: as shown in that last example, the value being validated is already sent to the help message string to format under the 'var_value' key, so you do not need to pass it. Obviously you can further customize your exception subclasses if you wish.","title":"c - message templating"},{"location":"#d-typeerror-or-valueerror","text":"ValidationError does not by default inherit from TypeError or ValueError , because in the general case, valid8 has no means of knowing. But you may have noticed in all of the output message examples shown above that one of the two is still appearing each time in the resulting exception. This is because valid8 automatically guesses: when a validation error happens, it recursively looks at the type of the failure cause for a TypeError or ValueError (default if nothing is found). It then dynamically creates an appropriate exception type inheriting both from ValidationError and from either TypeError or ValueError according to what has been found. This dynamic type is cached for speed considerations. It has some custom display methods that make it appear as follows: > validate ( 'surface' , -1, instance_of = int, min_value = 0 ) ValidationError [ ValueError ] > validate ( 'surface' , 1j, instance_of = int, min_value = 0 ) ValidationError [ TypeError ] If you do not wish the automatic guessing to happen, you can always declare the inheritance explicitly by creating custom subclasses inheriting from the one of your choice, or both: class InvalidSurface ( ValidationError , ValueError ): help_msg = \"\" If you create a custom subclass but do not inherit from TypeError nor ValueError , the automatic guessing will take place as usual.","title":"d - TypeError or ValueError"},{"location":"#main-features","text":"Separation of validation intent (entry points validate , validator , @validate_arg ...) from validation means (base validation code / functions). Entry points provide a clear and consistent behaviour matching your applicative intent, hiding the diversity of base validation functions that you rely on to do it. Clear entry points to serve most common needs related with validation: Inline validation : two functions validate and validator / validation to perform validation anywhere in your code. Function validation : two decorators @validate_arg and @validate_out , as well as a more limited @validate_io , to add input and output validation to any function. A manual decorator decorate_with_validation provides the same functionality for retrofit purposes. Class validation : one decorator @validate_field to add validation to class fields. Consistent behaviour : all defensive mode entry points provide the same behaviour, raising subclasses of ValidationError in case of failure, whatever the diversity of failure modes that can happen in base validation code. The exception object contains all contextual information in its fields so as to be easily usable by a global exception handler at application-level, for example for internationalization. Moreover, the appropriate TypeError or ValueError base class is dynamically added to the resulting exception type if not present already. Consistency is also ensured by the fact that all entry points rely on a common Validator class. Highly customizable : all entry points can be customized so as to fit your application needs. In particular you probably do not want users to see valid8 exceptions and messages, but rather your exceptions and messages. This is easy to do with the two help_msg and error_type options. python-first, not schema-first . This library is intended to provide validation anywhere in your code, not only when data enters a web service, a CLI or a form. There already are libs out there for that purpose. valid8 is rather meant to be as simple as possible and as open as possible to any kind of validation, even those that can not easily be described in a schema. Separation of value validation from type validation is possible . valid8 can be combined with any PEP484-based type validation library such as enforce or pytypes . Plays well with pyfields , autoclass and attrs . Declare validation once by annotating the class with @validate_field , and you're good to go! validation functions Compliant with most base validation functions out there . You may use base validation functions from anywhere including your own, and including functools.partial , lambda or even callable objects implementing the __call__ magic method. The only requirement is that they return True or None in case of success ! The way they fail is not important, valid8 tolerates all. If you wish to create your own, you can leverage the three exception classes provided. Built-in library of base validation functions , by object type. Do not hesitate to contribute! Also, do not hesitate to rely on other libraries for dedicated object types such as these , or to build your own ! Built-in support for mini_lambda to define base validation functions for the decorators, so that you do not need to write lambda x: everywhere, and the failure messages are far more easy to read. Besides the global error customization as well as built-in syntax for failure raiser definition allows you to easily add exception details to lambda expressions. Built-in composition framework . Built-in functions and_ , or_ , xor_ , not_ , not_all , failure_raiser , skip_on_none and fail_on_none allow you to quickly create complex validation functions by reusing simpler ones, if you do not want to do it using lambda or mini_lambda . In particular, and_ is implicitly used if you provide a list of base validation functions to any of the valid8 decorators.","title":"Main features"},{"location":"#other-validation-libraries","text":"Many validation libraries are available on PyPI already. The following list is by far not exhaustive, but gives an overview. Do not hesitate to contribute to this list with a pull request!","title":"Other Validation libraries"},{"location":"#origin-of-this-project","text":"When it all started, I was just looking for a library providing a @validate annotation with a basic library of validators and some logic to associate them, so as to complete autoclass . I searched and found tons of good and less good libraries out there . However none of them was really a good fit for autoclass , for diverse reasons: only a few of them were available as decorators many of them were strongly mixing type validation and value validation, which is not necessary anymore thanks to PEP484. This was making the autoclass examples more confusing. only a few of them were providing a simple yet consistent and reusable framework to deal with validation functions, combine them, etc. And the good ones were based on defining a Schema first, which seemed a bit 'too much' for me already. finally, none of them was really encouraging the community to collaborate by displaying a catalog of base validation functions per data type, open to contributions. So I first created the @validate goodie in autoclass . When the project became more mature, I decided to extract it and make it independent, so that maybe the community will find it interesting. When this project grew, I found that its embedded library of base validation functions was not flexible enough to cover a large variety of use cases, and will probably never be even if we try our best, so I came up with the complementary mini_lambda syntax which is now an independent project, typically used when your base validation function is very specific, but yet quite simple to write in plain python. Later on I decided to create a better alternative to autoclass , named pyfields . This challenged the valid8 project once again to be simple, clear, and extensible. This gave version 5.0.0 .","title":"Origin of this project"},{"location":"#see-also","text":"We had this discussion on python-ideas to suggest a validate statement, functional equivalent of assert_valid , that would be built-in the python syntax so as to reduce parenthesis. An issue was also created. Julien Danjou's Definitive Guide to Python Exceptions . It was of great inspiration and help to design valid8 's exception hierarchy. Do you like this library ? You might also like my other python libraries","title":"See Also"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-valid8","title":"Want to contribute ?"},{"location":"api_reference/","text":"API reference \u00b6 In general, help(symbol) will provide the latest up-to-date documentation. 1. inline \u00b6 validate \u00b6 todo validator / validation \u00b6 todo 2. functions \u00b6 @validate_arg \u00b6 todo @validate_out \u00b6 todo @validate_io \u00b6 todo 3. classes \u00b6 @validate_field \u00b6 todo 4. internals \u00b6 Validator \u00b6 todo assert_valid \u00b6 todo is_valid \u00b6 todo","title":"API reference"},{"location":"api_reference/#api-reference","text":"In general, help(symbol) will provide the latest up-to-date documentation.","title":"API reference"},{"location":"api_reference/#1-inline","text":"","title":"1. inline"},{"location":"api_reference/#validate","text":"todo","title":"validate"},{"location":"api_reference/#validator-validation","text":"todo","title":"validator / validation"},{"location":"api_reference/#2-functions","text":"","title":"2. functions"},{"location":"api_reference/#validate_arg","text":"todo","title":"@validate_arg"},{"location":"api_reference/#validate_out","text":"todo","title":"@validate_out"},{"location":"api_reference/#validate_io","text":"todo","title":"@validate_io"},{"location":"api_reference/#3-classes","text":"","title":"3. classes"},{"location":"api_reference/#validate_field","text":"todo","title":"@validate_field"},{"location":"api_reference/#4-internals","text":"","title":"4. internals"},{"location":"api_reference/#validator","text":"todo","title":"Validator"},{"location":"api_reference/#assert_valid","text":"todo","title":"assert_valid"},{"location":"api_reference/#is_valid","text":"todo","title":"is_valid"},{"location":"changelog/","text":"Changelog \u00b6 5.0.4 - pyproject.toml \u00b6 Added pyproject.toml . 5.0.3 - bug fixes \u00b6 Fixed bug with mini-lambda < 2.2. Fixed #48 . Fixed bug in is_in when the reference object was a non-set container. Fixed #47 . 5.0.2 - Bug fix \u00b6 Fixed regression with non-able detection. Fixed #46 . 5.0.0 - More betterness! \u00b6 Better syntax for *validation_func : you can provide a tuple (<callable>, <help_msg>, <failure_type>) to define a single failure raiser (before only (<callable>, <help_msg>) or (<callable>, <failure_type>) were supported). Fixes #33 you can provide a dict -like to define several validation functions, where the key and values can contain <callable> , <help_msg> , <failure_type> . For example {<help_msg>: (<callable>, <failure_type>)} is supported. Fixes #40 . nested lists are however not supported anymore the <callable> can now either have signature f(v) , f(*args) , f(*args, **ctx) or f(v, **ctx) , where **ctx can be used to receive contextual information. Fixes #39 validation_lib should be imported explicitly symbols from valid8.validation_lib are not imported automatically at package root anymore. You need to import them from valid8.validation_lib . This speeds up the library's import especially when you do not use the built-in functions. So instead of from valid8 import is_even you should now do from valid8.validation_lib import is_even (or from valid8 import validation_lib as vlib + vlib.is_even ). Fixed #35 . Major exceptions refactoring the main validation function in a Validator is now always a failure raiser, even if a single callable was provided. This major design choice made many simplifications possible in particular the string representation of exceptions (below). Fixes #44 The string representation of ValidationError and ValidationFailure was greatly improved. In particular ValidationError does not display the name and outcome of the validation function anymore (since it is always a failure, see above), and ValidationFailure now has a \"compact\" string representation option in a new to_str() method, used in composition messages to simplify the result. Composition failures are also represented in a more compact way. failure_raiser moved to base submodule with its associated type hints ValidationCallable and ValidationCallableOrLambda . It now only accepts a single validation function argument ; this is more intuitive and separates concerns with the other higher-level functions. If you used it with several inputs in the past, you can use and_(...) instead, it will be strictly equivalent to the old behaviour. new @as_failure_raiser decorator to create a failure raiser by decorating an existing validation function. Fixes #36 . WrappingFailure does not exist anymore, it was merged with Failure class for architecture simplification. So there are two main exception classes in valid8 now: ValidationError and ValidationFailure . When the validation callable does not raise an instance of ValidationFailure itself, the Invalid subclass is used. Fixes #41 Misc assert_subclass_of now exposed at root level (for consistency with assert_instance_of , to be used in the context manager entry point) Added __version__ attribute to comply with PEP396, following https://smarie.github.io/python-getversion/#package-versioning-best-practices. Fixes #38 . result_is_success is now inlined and does not use a set expression anymore. Fixed #37 Improved all examples of Failure in the validation lib to show how a better practice where the help_msg stays at class level but can be overridden failure instance by failure instance. Removed length_between open_left/right arguments as it does not make sense, to continue fixing #29 new subpackage utils where all util submodules now live New submodule common_syntax where all the logic to handle the *validation_func input syntax resides some type hints renamed for clarity: before: ValidationFuncs / ValidationFunc / CallableType / Callable now: OneOrSeveralVFDefinitions / ValidationFuncDefinition / ValidationCallableOrLamba / ValidationCallable . ValidationFuncs still exists as a short alias for OneOrSeveralVFDefinitions . fixed a few type hints too: tuples with unlimited length were not declared correctly. Now using the ellipsis Tuple[<type>, ...] . 4.2.1 - Minor error message fix \u00b6 Error messages improvements: removed the brackets in Wrong value: [...] for the Failure details. Fixed #32 . 4.2.0 - validation lib improvements \u00b6 Removed the useless 'strict' length validators: removed min_len_strict and max_len_strict in validate entry point, and removed strict argument in validation_lib 's minlen and maxlen . Indeed length is an integer by python framework definition, so it is always more compact to do +1 or -1 to the number. Fixes #29 . New empty and non_empty built-in validators in validation_lib . New empty argument in validate . Fixes #31 . 4.1.2 - Bugfix for python 3.5.2 \u00b6 Fixed #30 again, and fixed issue with python 2 appearing with the fix. 4.1.1 - Bugfix for python 3.5.2 \u00b6 Fixed #30 . 4.1.0 - validate instance/subclass fix \u00b6 assert_instance_of and assert_subclass_of (used in the validate inline entry point) fixed so as to support Enum types. Fixed #28 . Important : only tuple are now supported when several types are provided in validate 's instance_of and subclass_of arguments. This is to has a closer behaviour to the python stdlib. 4.0.1 - better mini-lambda compliance \u00b6 Adapted code to leverage latest mini_lambda . Fixes #27 . 4.0.0 - python 2.7 support + minor improvements \u00b6 Python 2.7 is now supported. This fixes #25 . Dependencies updated: now makefun is used instead of decorator to create signature-preserving wrappers. decopatch is also used to create all the decorators consistently. assert_instance_of and assert_subclass_of (used in the validate inline entry point) were improved so as to benefit from python 3's capability to compare with several classes, and so that users can provide the reference classes as an iterable rather than a set. Fixes #26 . More compact tracebacks for validate method: removed exception causes. Fixed type inspection for old python 3.5 versions. 3.7.3 - python 3.7 support \u00b6 Fixed #24 3.7.2 - Bug fix \u00b6 Fixed #23 3.7.1 - Bug fix \u00b6 Fixed #22 3.7.0 - Typos detection and np.nan handling \u00b6 Fixed typos detection: #21 Fixed np.nan handling: #20 3.6.0 - Error messages improvements + create_manually class method in ValidationError \u00b6 values with string representation larger than 100 characters are not anymore displayed in the error messages by default. Fixes #19 new class method ValidationError.create_manually to create validation errors manually in some edge cases, without a validator entry point 3.5.5 - Fixed import * issue \u00b6 Fixes #18 3.5.4 - Improved init \u00b6 The init file has been improved so as not to export symbols from other packages. Fixes #15 3.5.3 - fixed optionality detection bug \u00b6 internal custom copy of typing_inspect module was correct for old versions of python but created a bug on new versions of python: optionality detection was not working anymore when using Optional[] . Fixes #16 3.5.2 - support for older version of typing.py \u00b6 removed dependency to typing_inspect module so that the module also runs with very old versions of typing.py 3.5.1 - Improved tracebacks \u00b6 Fixed #14 3.5.0 - improved PEP484-nonable detection \u00b6 Now relying on typing_inspect to check if an argument is nonable, with support of TypeVar and Union including nesting. 3.4.0 - new features \u00b6 Inline validation: validate has a new argument custom where you can provide a callable method, or a list (same than for the decorators) Examples: one page per example - now with a dedicated test in the sources mini-lambda support: now providing an Instance_of mini-lambda equivalent of instance_of , to raise proper TypeError . See example 3 for usage 3.3.0 - new features \u00b6 Inline validation: validate has several new arguments: subclass_of , contains , subset_of , superset_of , length , equals validator has a new argument: subclass_of New base function assert_subclass_of instance_of and subclass_of are now dual functions: they can both serve as a function generators or as a simple functions for inline validation for example inside a validator context manager. Decorators: 2 new function generators has_length and contains Bug fixes: Fixed bug #11 where ValidationError could not be correctly printed in case of a templating issue. New examples in the documentation 3.2.0 - new names and aliases for readability \u00b6 wrap_valid context manager was renamed validation with alias validator . The deprecated old name remains accepted until next major release 4.x. quick_valid function was renamed validate . The deprecated old name remains accepted until next major release 4.x. @validate decorator was renamed @validate_io . The old name is now used to denote quick_valid , see above. Its alidate alias was removed (was it used anyway ?) 3.1.0 - new instanceof parameter \u00b6 quick_valid 's parameters allowed_types and allowed_values were renamed instance_of and is_in respectively. instance_of parameter has been added to wrap_valid too. This solved #10 assert_instance_of function is now available for use with wrap_valid 3.0.1 - fixed bug with wrap_valid when run from a terminal \u00b6 Fixed #8 (OSError when executing from interpreter terminal) 3.0.0 - new inline validators + dynamic exception typing \u00b6 Added two new entry points that should be more useful and usable than assert_valid for inline validation: quick_valid for limited but simple one-line validation (most common tasks) wrap_valid for more flexible validation (a contextmanager so it takes 2 lines) ValidationError does not inherit from ValueError anymore. Instead an exception type is dynamically created with the appropriate base class (either ValueError or TypeError ) when a validation exception is raised. This can be disabled by explicitly inheriting from one or the other in custom exception types. improved documentation overall Now compliant with old versions of typing module: typing.Type is not imported explicitly anymore. 2.1.0 - new annotation @validate_field \u00b6 @validate_field allows users to validate class fields, whether they are descriptors, properties, or constructor arguments. Check the documentation for details! 2.0.0 - Major improvements and refactoring \u00b6 New and improved entry points: Function inputs validation : @validate_arg may be used instead of @validate to add input validation argument by argument instead of all in the same decorator (same functionality, this is just a question of style). A new decorator @validate_out is provided. The manual decorator validate_decorate was also renamed decorate_with_validation for clarity Inline validation : two new functions assert_valid and is_valid , allowing users to perform validation anywhere in their code in defensive programming mode ( assert_valid ) or case handling mode ( is_valid ) Common Validator class : the common logic behind all the above entry points. It offers two methods for defensive programming ( validator.assert_valid ) and case handling ( validator.is_valid ). It may also be used directly by users, to 'pre-compile' validators, so that they are not constructed at every call like when using assert_valid and is_valid . But the difference is probably negligible. Clearer separation of concepts: Entry points (the above) know the full validation context, and raise ValidationError (or a subclass such as InputValidationError or your custom subclass) when validation fails. The ValidationError object holds all information available concerning that validation context, and may be used by your application to improve or internationalize error messages. Base validation functions (your methods or the ones from utility libraries including valid8) may raise subclasses of Failure or WrappingFailure if they wish to benefit from this helper type as well as ease application-level error handling and internationalization. The helper method failure_raiser allows to add such a friendly exception to a method not raising it (such as a lambda). Better syntax to define base validation functions in entry points: base validation function(s) can be provided as a callable, a tuple(callable, help_msg_str), a tuple(callable, failure_type), or a list of several such elements. Nested lists are supported and indicate an implicit and_ (such as the main list). mini_lambda expressions can be used instead of callables, they will be transformed to functions automatically. Tuples indicate an implicit failure_raiser . Combined with mini_lambda, this is a very powerful way to create validation functions: (Len(s) > 0, 'The value should be an empty string') or (Len(s) > 0, EmptyStringFailure) . Minor improvements of the base functions library split in independent files collections , comparables , numbers in a validation_lib submodule so as to ease maintenance and possible contributions in the future added length_between validator added type validation functions instance_of and subclass_of all functions now raise unique subclasses of Failure ('eat your own dog food') Most built-in validator generators have their corresponding __name__ now correctly set resulting in more user-friendly error messages Improvements of the composition operators and_ , or_ , xor_ now support variable number of arguments (no need to pass a list anymore) not_ , and_ , or_ , xor_ now raise consistent exceptions (subclasses of CompositionFailure ), with a user-friendly error message indicating the detailed validation results. A lot of new tests 1.0.0 - First public version \u00b6 Initial fork from autoclass 1.8.1","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#504-pyprojecttoml","text":"Added pyproject.toml .","title":"5.0.4 - pyproject.toml"},{"location":"changelog/#503-bug-fixes","text":"Fixed bug with mini-lambda < 2.2. Fixed #48 . Fixed bug in is_in when the reference object was a non-set container. Fixed #47 .","title":"5.0.3 - bug fixes"},{"location":"changelog/#502-bug-fix","text":"Fixed regression with non-able detection. Fixed #46 .","title":"5.0.2 - Bug fix"},{"location":"changelog/#500-more-betterness","text":"Better syntax for *validation_func : you can provide a tuple (<callable>, <help_msg>, <failure_type>) to define a single failure raiser (before only (<callable>, <help_msg>) or (<callable>, <failure_type>) were supported). Fixes #33 you can provide a dict -like to define several validation functions, where the key and values can contain <callable> , <help_msg> , <failure_type> . For example {<help_msg>: (<callable>, <failure_type>)} is supported. Fixes #40 . nested lists are however not supported anymore the <callable> can now either have signature f(v) , f(*args) , f(*args, **ctx) or f(v, **ctx) , where **ctx can be used to receive contextual information. Fixes #39 validation_lib should be imported explicitly symbols from valid8.validation_lib are not imported automatically at package root anymore. You need to import them from valid8.validation_lib . This speeds up the library's import especially when you do not use the built-in functions. So instead of from valid8 import is_even you should now do from valid8.validation_lib import is_even (or from valid8 import validation_lib as vlib + vlib.is_even ). Fixed #35 . Major exceptions refactoring the main validation function in a Validator is now always a failure raiser, even if a single callable was provided. This major design choice made many simplifications possible in particular the string representation of exceptions (below). Fixes #44 The string representation of ValidationError and ValidationFailure was greatly improved. In particular ValidationError does not display the name and outcome of the validation function anymore (since it is always a failure, see above), and ValidationFailure now has a \"compact\" string representation option in a new to_str() method, used in composition messages to simplify the result. Composition failures are also represented in a more compact way. failure_raiser moved to base submodule with its associated type hints ValidationCallable and ValidationCallableOrLambda . It now only accepts a single validation function argument ; this is more intuitive and separates concerns with the other higher-level functions. If you used it with several inputs in the past, you can use and_(...) instead, it will be strictly equivalent to the old behaviour. new @as_failure_raiser decorator to create a failure raiser by decorating an existing validation function. Fixes #36 . WrappingFailure does not exist anymore, it was merged with Failure class for architecture simplification. So there are two main exception classes in valid8 now: ValidationError and ValidationFailure . When the validation callable does not raise an instance of ValidationFailure itself, the Invalid subclass is used. Fixes #41 Misc assert_subclass_of now exposed at root level (for consistency with assert_instance_of , to be used in the context manager entry point) Added __version__ attribute to comply with PEP396, following https://smarie.github.io/python-getversion/#package-versioning-best-practices. Fixes #38 . result_is_success is now inlined and does not use a set expression anymore. Fixed #37 Improved all examples of Failure in the validation lib to show how a better practice where the help_msg stays at class level but can be overridden failure instance by failure instance. Removed length_between open_left/right arguments as it does not make sense, to continue fixing #29 new subpackage utils where all util submodules now live New submodule common_syntax where all the logic to handle the *validation_func input syntax resides some type hints renamed for clarity: before: ValidationFuncs / ValidationFunc / CallableType / Callable now: OneOrSeveralVFDefinitions / ValidationFuncDefinition / ValidationCallableOrLamba / ValidationCallable . ValidationFuncs still exists as a short alias for OneOrSeveralVFDefinitions . fixed a few type hints too: tuples with unlimited length were not declared correctly. Now using the ellipsis Tuple[<type>, ...] .","title":"5.0.0 - More betterness!"},{"location":"changelog/#421-minor-error-message-fix","text":"Error messages improvements: removed the brackets in Wrong value: [...] for the Failure details. Fixed #32 .","title":"4.2.1 - Minor error message fix"},{"location":"changelog/#420-validation-lib-improvements","text":"Removed the useless 'strict' length validators: removed min_len_strict and max_len_strict in validate entry point, and removed strict argument in validation_lib 's minlen and maxlen . Indeed length is an integer by python framework definition, so it is always more compact to do +1 or -1 to the number. Fixes #29 . New empty and non_empty built-in validators in validation_lib . New empty argument in validate . Fixes #31 .","title":"4.2.0 - validation lib improvements"},{"location":"changelog/#412-bugfix-for-python-352","text":"Fixed #30 again, and fixed issue with python 2 appearing with the fix.","title":"4.1.2 - Bugfix for python 3.5.2"},{"location":"changelog/#411-bugfix-for-python-352","text":"Fixed #30 .","title":"4.1.1 - Bugfix for python 3.5.2"},{"location":"changelog/#410-validate-instancesubclass-fix","text":"assert_instance_of and assert_subclass_of (used in the validate inline entry point) fixed so as to support Enum types. Fixed #28 . Important : only tuple are now supported when several types are provided in validate 's instance_of and subclass_of arguments. This is to has a closer behaviour to the python stdlib.","title":"4.1.0 - validate instance/subclass fix"},{"location":"changelog/#401-better-mini-lambda-compliance","text":"Adapted code to leverage latest mini_lambda . Fixes #27 .","title":"4.0.1 - better mini-lambda compliance"},{"location":"changelog/#400-python-27-support-minor-improvements","text":"Python 2.7 is now supported. This fixes #25 . Dependencies updated: now makefun is used instead of decorator to create signature-preserving wrappers. decopatch is also used to create all the decorators consistently. assert_instance_of and assert_subclass_of (used in the validate inline entry point) were improved so as to benefit from python 3's capability to compare with several classes, and so that users can provide the reference classes as an iterable rather than a set. Fixes #26 . More compact tracebacks for validate method: removed exception causes. Fixed type inspection for old python 3.5 versions.","title":"4.0.0 - python 2.7 support + minor improvements"},{"location":"changelog/#373-python-37-support","text":"Fixed #24","title":"3.7.3 - python 3.7 support"},{"location":"changelog/#372-bug-fix","text":"Fixed #23","title":"3.7.2 - Bug fix"},{"location":"changelog/#371-bug-fix","text":"Fixed #22","title":"3.7.1 - Bug fix"},{"location":"changelog/#370-typos-detection-and-npnan-handling","text":"Fixed typos detection: #21 Fixed np.nan handling: #20","title":"3.7.0 - Typos detection and np.nan handling"},{"location":"changelog/#360-error-messages-improvements-create_manually-class-method-in-validationerror","text":"values with string representation larger than 100 characters are not anymore displayed in the error messages by default. Fixes #19 new class method ValidationError.create_manually to create validation errors manually in some edge cases, without a validator entry point","title":"3.6.0 - Error messages improvements + create_manually class method in ValidationError"},{"location":"changelog/#355-fixed-import-issue","text":"Fixes #18","title":"3.5.5 - Fixed import * issue"},{"location":"changelog/#354-improved-init","text":"The init file has been improved so as not to export symbols from other packages. Fixes #15","title":"3.5.4 - Improved init"},{"location":"changelog/#353-fixed-optionality-detection-bug","text":"internal custom copy of typing_inspect module was correct for old versions of python but created a bug on new versions of python: optionality detection was not working anymore when using Optional[] . Fixes #16","title":"3.5.3 - fixed optionality detection bug"},{"location":"changelog/#352-support-for-older-version-of-typingpy","text":"removed dependency to typing_inspect module so that the module also runs with very old versions of typing.py","title":"3.5.2 - support for older version of typing.py"},{"location":"changelog/#351-improved-tracebacks","text":"Fixed #14","title":"3.5.1 - Improved tracebacks"},{"location":"changelog/#350-improved-pep484-nonable-detection","text":"Now relying on typing_inspect to check if an argument is nonable, with support of TypeVar and Union including nesting.","title":"3.5.0 - improved PEP484-nonable detection"},{"location":"changelog/#340-new-features","text":"Inline validation: validate has a new argument custom where you can provide a callable method, or a list (same than for the decorators) Examples: one page per example - now with a dedicated test in the sources mini-lambda support: now providing an Instance_of mini-lambda equivalent of instance_of , to raise proper TypeError . See example 3 for usage","title":"3.4.0 - new features"},{"location":"changelog/#330-new-features","text":"Inline validation: validate has several new arguments: subclass_of , contains , subset_of , superset_of , length , equals validator has a new argument: subclass_of New base function assert_subclass_of instance_of and subclass_of are now dual functions: they can both serve as a function generators or as a simple functions for inline validation for example inside a validator context manager. Decorators: 2 new function generators has_length and contains Bug fixes: Fixed bug #11 where ValidationError could not be correctly printed in case of a templating issue. New examples in the documentation","title":"3.3.0 - new features"},{"location":"changelog/#320-new-names-and-aliases-for-readability","text":"wrap_valid context manager was renamed validation with alias validator . The deprecated old name remains accepted until next major release 4.x. quick_valid function was renamed validate . The deprecated old name remains accepted until next major release 4.x. @validate decorator was renamed @validate_io . The old name is now used to denote quick_valid , see above. Its alidate alias was removed (was it used anyway ?)","title":"3.2.0 - new names and aliases for readability"},{"location":"changelog/#310-new-instanceof-parameter","text":"quick_valid 's parameters allowed_types and allowed_values were renamed instance_of and is_in respectively. instance_of parameter has been added to wrap_valid too. This solved #10 assert_instance_of function is now available for use with wrap_valid","title":"3.1.0 - new instanceof parameter"},{"location":"changelog/#301-fixed-bug-with-wrap_valid-when-run-from-a-terminal","text":"Fixed #8 (OSError when executing from interpreter terminal)","title":"3.0.1 - fixed bug with wrap_valid when run from a terminal"},{"location":"changelog/#300-new-inline-validators-dynamic-exception-typing","text":"Added two new entry points that should be more useful and usable than assert_valid for inline validation: quick_valid for limited but simple one-line validation (most common tasks) wrap_valid for more flexible validation (a contextmanager so it takes 2 lines) ValidationError does not inherit from ValueError anymore. Instead an exception type is dynamically created with the appropriate base class (either ValueError or TypeError ) when a validation exception is raised. This can be disabled by explicitly inheriting from one or the other in custom exception types. improved documentation overall Now compliant with old versions of typing module: typing.Type is not imported explicitly anymore.","title":"3.0.0 - new inline validators + dynamic exception typing"},{"location":"changelog/#210-new-annotation-validate_field","text":"@validate_field allows users to validate class fields, whether they are descriptors, properties, or constructor arguments. Check the documentation for details!","title":"2.1.0 - new annotation @validate_field"},{"location":"changelog/#200-major-improvements-and-refactoring","text":"New and improved entry points: Function inputs validation : @validate_arg may be used instead of @validate to add input validation argument by argument instead of all in the same decorator (same functionality, this is just a question of style). A new decorator @validate_out is provided. The manual decorator validate_decorate was also renamed decorate_with_validation for clarity Inline validation : two new functions assert_valid and is_valid , allowing users to perform validation anywhere in their code in defensive programming mode ( assert_valid ) or case handling mode ( is_valid ) Common Validator class : the common logic behind all the above entry points. It offers two methods for defensive programming ( validator.assert_valid ) and case handling ( validator.is_valid ). It may also be used directly by users, to 'pre-compile' validators, so that they are not constructed at every call like when using assert_valid and is_valid . But the difference is probably negligible. Clearer separation of concepts: Entry points (the above) know the full validation context, and raise ValidationError (or a subclass such as InputValidationError or your custom subclass) when validation fails. The ValidationError object holds all information available concerning that validation context, and may be used by your application to improve or internationalize error messages. Base validation functions (your methods or the ones from utility libraries including valid8) may raise subclasses of Failure or WrappingFailure if they wish to benefit from this helper type as well as ease application-level error handling and internationalization. The helper method failure_raiser allows to add such a friendly exception to a method not raising it (such as a lambda). Better syntax to define base validation functions in entry points: base validation function(s) can be provided as a callable, a tuple(callable, help_msg_str), a tuple(callable, failure_type), or a list of several such elements. Nested lists are supported and indicate an implicit and_ (such as the main list). mini_lambda expressions can be used instead of callables, they will be transformed to functions automatically. Tuples indicate an implicit failure_raiser . Combined with mini_lambda, this is a very powerful way to create validation functions: (Len(s) > 0, 'The value should be an empty string') or (Len(s) > 0, EmptyStringFailure) . Minor improvements of the base functions library split in independent files collections , comparables , numbers in a validation_lib submodule so as to ease maintenance and possible contributions in the future added length_between validator added type validation functions instance_of and subclass_of all functions now raise unique subclasses of Failure ('eat your own dog food') Most built-in validator generators have their corresponding __name__ now correctly set resulting in more user-friendly error messages Improvements of the composition operators and_ , or_ , xor_ now support variable number of arguments (no need to pass a list anymore) not_ , and_ , or_ , xor_ now raise consistent exceptions (subclasses of CompositionFailure ), with a user-friendly error message indicating the detailed validation results. A lot of new tests","title":"2.0.0 - Major improvements and refactoring"},{"location":"changelog/#100-first-public-version","text":"Initial fork from autoclass 1.8.1","title":"1.0.0 - First public version"},{"location":"long_description/","text":"python-validate (valid8) \u00b6 \"valid8ing is not a crime\" ;-) valid8 provides user-friendly tools for 3 kind of \"entry points\": general-purpose inline validation (=anywhere in your code), function inputs/outputs validation class fields validation. All these entry points raise consistent ValidationError including user-friendly details, with inheritance of ValueError / TypeError as appropriate. You can customize this error so as to get unique error types convenient for i18n. The documentation for users is available here: https://smarie.github.io/python-valid8/ A readme for developers is available here: https://github.com/smarie/python-valid8","title":"python-validate (valid8)"},{"location":"long_description/#python-validate-valid8","text":"\"valid8ing is not a crime\" ;-) valid8 provides user-friendly tools for 3 kind of \"entry points\": general-purpose inline validation (=anywhere in your code), function inputs/outputs validation class fields validation. All these entry points raise consistent ValidationError including user-friendly details, with inheritance of ValueError / TypeError as appropriate. You can customize this error so as to get unique error types convenient for i18n. The documentation for users is available here: https://smarie.github.io/python-valid8/ A readme for developers is available here: https://github.com/smarie/python-valid8","title":"python-validate (valid8)"},{"location":"other_libs/","text":"Other Validation libraries \u00b6 Many validation libraries are available on PyPI already. The following list is by far not exhaustive, but gives an overview. Do not hesitate to contribute to this list with a pull request! For each library, the date provided is that of the last commit at the time of writing (10/2017). Note to the authors: due to the large number of libraries below there must have been errors in my analysis. Please let me know if I wrote something wrong, the intent is really not to criticize your library but rather to better understand the various mechanisms available out there for reuse. PEP484 type checkers \u00b6 The following libraries use your PEP484 type and optionality/mandatoryness annotations to check the function inputs and sometimes outputs. enforce pytypes typeguard typecheck-decorator Type+Value validation \u00b6 The following frameworks provide both type and value validation, and for most of them it would be quite irrelevant to separate value validation from type validation. PyContracts : (2017) Annotation. Parsing-based (the contract is a string when it comes to value validation). Ability to disable through a function call. Validators are functions or specific predefined grammar elements. Logical operations on validators are supported. thedoctor : (2015) Annotation. Ability to disable with an environment variable. Dictionary validation. Helper true to support lambdas while throwing validation exceptions. A few validators. Validators are functions. No logical operations on validators. fivalid :(2012) number, iterable, basic min/max, many text validators : free text with forbidden sentences, regexp, split on parts, All/Any/Not validator logic, a validator is an object validate : (2009) quite old, a few basic validators (str/list length, int min/max values, ip_addr) mixed with type validation. Validators are functions. Value validation \u00b6 I recently found these two elegant frameworks: expects grappa Mostly Type validation \u00b6 These packages seem to mostly have been developed for type validation, not much for value validation: py-validate : (2017) a few non-type validators even, odd, number. Validators ('shortcuts') are functions. pyvalid : (2017) mostly type validation except for value equality or size. Object fields validation. A validator is an object, collection of smaller checkers (StringValidator has min_len checker, max_len_checker, etc.) Schema-based validation \u00b6 These libraries check that data is valid with respect to a schema . voluptuous (2017) schema (2017) datatyping (2017) pyvalidator (2015) a modified fork of schema validr (2017) \"10X faster than jsonschema, 40X faster than schematics\". Based on Isomorph-JSON-Schema colander (2017). A framework for serialization+deserialization including schema validation. With validators for strings, mappings, and lists python-jsonschema-objects (2017). Automatic Python binding generation from JSON Schemas PyValitron (2016) separation of the concepts of validators / sanitizers (for text: lower case, strip, etc.). Quite a number of validators. validator (2014) A few built-in validators. validator are objects (Rule) jsonobject (2017): specific to json Validation of data 'at the application's entry point' \u00b6 If your application can only receive data from the outside world through forms, CLI or web service inputs, you might wish to validate as early as possible (as soon as it is received) that it is correct. This is what these libraries provide: from Forms \u00b6 Data from forms sometimes requires validation to follow some kind of process with several steps, where a validation context (permissions) may need to be maintained. formencode : (2017) a complete framework to validate and convert data entered in forms. Includes a number of domain-specific validators kanone (2013) validation and conversion of data entered in forms. Notion of context. validator logic + composition (to reuse while parametrizing) django forms : (2017) provides a number of built-in Field classes from CLI \u00b6 click (2017) integrates a number of built-in validators for arguments and options (file paths, etc.) docopt (2016) delegates to schema for validation Domain-specific validators / validators for specific data types / validators without framework \u00b6 These packages provide base validation functions, not validation frameworks. Therefore you could wish to reuse some of these functions in combination with valid8 . pandas-validation : (2017) pandas dataframes pandas-validator : (2017) pandas dataframes validators : (2017) email, iban, ip, slug, truthy, url, uuid, finnish business id... validatish (2011): a few validation functions for integers, strings, required/optional, etc. python-phonenumbers (2017): guess what? validate-email-address (2016): guess what ? It is a fork of validate_email (2015). ... Other resources concerning validation frameworks: \u00b6 A discussion about the various frameworks out there The apache commons lib for validation","title":"Other validation libs"},{"location":"other_libs/#other-validation-libraries","text":"Many validation libraries are available on PyPI already. The following list is by far not exhaustive, but gives an overview. Do not hesitate to contribute to this list with a pull request! For each library, the date provided is that of the last commit at the time of writing (10/2017). Note to the authors: due to the large number of libraries below there must have been errors in my analysis. Please let me know if I wrote something wrong, the intent is really not to criticize your library but rather to better understand the various mechanisms available out there for reuse.","title":"Other Validation libraries"},{"location":"other_libs/#pep484-type-checkers","text":"The following libraries use your PEP484 type and optionality/mandatoryness annotations to check the function inputs and sometimes outputs. enforce pytypes typeguard typecheck-decorator","title":"PEP484 type checkers"},{"location":"other_libs/#typevalue-validation","text":"The following frameworks provide both type and value validation, and for most of them it would be quite irrelevant to separate value validation from type validation. PyContracts : (2017) Annotation. Parsing-based (the contract is a string when it comes to value validation). Ability to disable through a function call. Validators are functions or specific predefined grammar elements. Logical operations on validators are supported. thedoctor : (2015) Annotation. Ability to disable with an environment variable. Dictionary validation. Helper true to support lambdas while throwing validation exceptions. A few validators. Validators are functions. No logical operations on validators. fivalid :(2012) number, iterable, basic min/max, many text validators : free text with forbidden sentences, regexp, split on parts, All/Any/Not validator logic, a validator is an object validate : (2009) quite old, a few basic validators (str/list length, int min/max values, ip_addr) mixed with type validation. Validators are functions.","title":"Type+Value validation"},{"location":"other_libs/#value-validation","text":"I recently found these two elegant frameworks: expects grappa","title":"Value validation"},{"location":"other_libs/#mostly-type-validation","text":"These packages seem to mostly have been developed for type validation, not much for value validation: py-validate : (2017) a few non-type validators even, odd, number. Validators ('shortcuts') are functions. pyvalid : (2017) mostly type validation except for value equality or size. Object fields validation. A validator is an object, collection of smaller checkers (StringValidator has min_len checker, max_len_checker, etc.)","title":"Mostly Type validation"},{"location":"other_libs/#schema-based-validation","text":"These libraries check that data is valid with respect to a schema . voluptuous (2017) schema (2017) datatyping (2017) pyvalidator (2015) a modified fork of schema validr (2017) \"10X faster than jsonschema, 40X faster than schematics\". Based on Isomorph-JSON-Schema colander (2017). A framework for serialization+deserialization including schema validation. With validators for strings, mappings, and lists python-jsonschema-objects (2017). Automatic Python binding generation from JSON Schemas PyValitron (2016) separation of the concepts of validators / sanitizers (for text: lower case, strip, etc.). Quite a number of validators. validator (2014) A few built-in validators. validator are objects (Rule) jsonobject (2017): specific to json","title":"Schema-based validation"},{"location":"other_libs/#validation-of-data-at-the-applications-entry-point","text":"If your application can only receive data from the outside world through forms, CLI or web service inputs, you might wish to validate as early as possible (as soon as it is received) that it is correct. This is what these libraries provide:","title":"Validation of data 'at the application's entry point'"},{"location":"other_libs/#from-forms","text":"Data from forms sometimes requires validation to follow some kind of process with several steps, where a validation context (permissions) may need to be maintained. formencode : (2017) a complete framework to validate and convert data entered in forms. Includes a number of domain-specific validators kanone (2013) validation and conversion of data entered in forms. Notion of context. validator logic + composition (to reuse while parametrizing) django forms : (2017) provides a number of built-in Field classes","title":"from Forms"},{"location":"other_libs/#from-cli","text":"click (2017) integrates a number of built-in validators for arguments and options (file paths, etc.) docopt (2016) delegates to schema for validation","title":"from CLI"},{"location":"other_libs/#domain-specific-validators-validators-for-specific-data-types-validators-without-framework","text":"These packages provide base validation functions, not validation frameworks. Therefore you could wish to reuse some of these functions in combination with valid8 . pandas-validation : (2017) pandas dataframes pandas-validator : (2017) pandas dataframes validators : (2017) email, iban, ip, slug, truthy, url, uuid, finnish business id... validatish (2011): a few validation functions for integers, strings, required/optional, etc. python-phonenumbers (2017): guess what? validate-email-address (2016): guess what ? It is a fork of validate_email (2015). ...","title":"Domain-specific validators / validators for specific data types / validators without framework"},{"location":"other_libs/#other-resources-concerning-validation-frameworks","text":"A discussion about the various frameworks out there The apache commons lib for validation","title":"Other resources concerning validation frameworks:"},{"location":"usage/","text":"Validation entry points \u00b6 Defensive programming - from assert to validate \u00b6 Let's start with a very simple hello function: def hello ( age ): print ( 'Hello, {}-years-old fella !' . format ( age )) We would like to protect it against bad data, for one of the reasons listed here . A first idea would probably be to use assert : from math import isfinite , inf def hello ( age ): assert isfinite ( age ) print ( 'Hello, {}-years-old fella !' . format ( age )) # let's test that it works: hello ( 33 ) # 'Hello, 33-years-old fella !' hello ( inf ) # AssertionError: assert False \\ # where False = <built-in function isfinite>(inf) But as explained here this is maybe not satisfying: either the code may be used in an optimized environment and we don't want the assertion to disappear, or we think that the type of error raised by assert is not satisfying/user-friendly/consistent/good enough for app-wide error handling/i18n...(pick your favorite) Let's replace assert with validate from valid8 : from math import isfinite , inf from valid8 import validate def hello ( age ): validate ( 'age' , age , custom = isfinite ) print ( 'Hello, {}-years-old fella !' . format ( age )) # let's test that it works: hello ( inf ) # ValidationError: Error validating [age=inf]: \\ # root validator [isfinite] returned [False]. As you can see above, our code is very similar to the one with assert , but the exception raised is now a ValidationError (and would be so even if isfinite had raised an exception), displaying all details about the validation context and the failure. We can inspect the exception to check that all this information is also available in the object itself: try : hello ( inf ) except ValidationError as e : e . validator # \"Validator<isfinite>\" e . var_name # 'age' e . var_value # inf e . validation_outcome # False We will come back later to the notion of Validator object that appears here in e.validator . One of the great features of valid8 is that it will fail consistently, whatever the way the inner validation function fails: hello ( None ) # ValidationError * * WORK IN PROGRESS : TODO CONTINUE * *","title":"Validation entry points"},{"location":"usage/#validation-entry-points","text":"","title":"Validation entry points"},{"location":"usage/#defensive-programming-from-assert-to-validate","text":"Let's start with a very simple hello function: def hello ( age ): print ( 'Hello, {}-years-old fella !' . format ( age )) We would like to protect it against bad data, for one of the reasons listed here . A first idea would probably be to use assert : from math import isfinite , inf def hello ( age ): assert isfinite ( age ) print ( 'Hello, {}-years-old fella !' . format ( age )) # let's test that it works: hello ( 33 ) # 'Hello, 33-years-old fella !' hello ( inf ) # AssertionError: assert False \\ # where False = <built-in function isfinite>(inf) But as explained here this is maybe not satisfying: either the code may be used in an optimized environment and we don't want the assertion to disappear, or we think that the type of error raised by assert is not satisfying/user-friendly/consistent/good enough for app-wide error handling/i18n...(pick your favorite) Let's replace assert with validate from valid8 : from math import isfinite , inf from valid8 import validate def hello ( age ): validate ( 'age' , age , custom = isfinite ) print ( 'Hello, {}-years-old fella !' . format ( age )) # let's test that it works: hello ( inf ) # ValidationError: Error validating [age=inf]: \\ # root validator [isfinite] returned [False]. As you can see above, our code is very similar to the one with assert , but the exception raised is now a ValidationError (and would be so even if isfinite had raised an exception), displaying all details about the validation context and the failure. We can inspect the exception to check that all this information is also available in the object itself: try : hello ( inf ) except ValidationError as e : e . validator # \"Validator<isfinite>\" e . var_name # 'age' e . var_value # inf e . validation_outcome # False We will come back later to the notion of Validator object that appears here in e.validator . One of the great features of valid8 is that it will fail consistently, whatever the way the inner validation function fails: hello ( None ) # ValidationError * * WORK IN PROGRESS : TODO CONTINUE * *","title":"Defensive programming - from assert to validate"},{"location":"valid8_with_other/","text":"valid8 + other tools \u00b6 Other validation styles \u00b6 The checktypes package provides a way to easily embed your validation requirements as classes, for easy reuse. from valid8 import validate from checktypes import checktype PositiveInt = checktype ( 'PositiveInt' , int , lambda x : x > 0 ) x = 1 validate ( 'x' , x , custom = PositiveInt . validate ) x = - 1 validate ( 'x' , x , custom = PositiveInt . validate ) # ValidationError For functions and classes \u00b6 PEP484 type checkers \u00b6 Although simple type validation may be performed using valid8 , for function inputs/outputs type validation as well as class field type validation you may wish to rely on a proper PEP484 type checker such as enforce or pytypes . The following snippet shows a build_house function with two inputs name and surface , where each input is: validated against the expected type thanks to the PEP484 type checking library ( enforce in this example) further value-validated with valid8 ( len(name) > 0 and surface >= 0 ), with the help of the mini_lambda syntax. # Imports - for type validation from numbers import Integral from typing import Tuple , Optional from enforce import runtime_validation , config config ( dict ( mode = 'covariant' )) # type validation will accept subclasses too # Imports - for value validation from mini_lambda import s , x , Len from valid8 import validate_arg , is_multiple_of , InputValidationError # Define our 2 applicative error types class InvalidNameError ( InputValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurfaceError ( InputValidationError ): help_msg = 'Surface should be a multiple of 100 between 0 and 10000.' # Apply type + value validation @runtime_validation @validate_arg ( 'name' , Len ( s ) > 0 , error_type = InvalidNameError ) @validate_arg ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurfaceError ) def build_house ( name : str , surface : Optional [ Integral ] = None ) \\ -> Tuple [ str , Optional [ Integral ]]: print ( 'Building house... DONE !' ) return name , surface We can test that validation works: > build_house ( 'sweet home' , 200 ) # valid > build_house ( 'sweet home' ) # valid (PEP484 Optional, default=None) > build_house ( '' , 100 ) # InvalidNameError (valid8) > build_house ( 'sweet home' , 10000 ) # InvalidSurfaceError (valid8) > build_house ( 'test' , 100 .1 ) # RuntimeTypeError (enforce) Note concerning PEP484 type validation : how can you make sure to accept both plain old float , int and bool , as well as their numpy equivalents ? Use the handy Real (=float) and Integral (=int) abstract numeric types provided in the numbers built-in module ! They provide an easy way to support both python primitives AND others, e.g. numpy primitives. Unfortunately no equivalent type is provided in the stdlib for booleans, so in valid8 we provide an additional Boolean class supporting numpy, to complete the picture. For classes \u00b6 pyfields \u00b6 TODO autoclass \u00b6 valid8 plays well with autoclass to quickly create small but validated classes: If you decorate the whole class with @validate_field the property setters generated by @autoclass will include validation, as expected: from autoclass import autoclass from mini_lambda import s , x , Len from valid8 import validate_arg , instance_of , is_multiple_of class InvalidNameError ( ClassFieldValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurfaceError ( ClassFieldValidationError ): help_msg = 'Surface should be a multiple of 100 between 0 and 10000.' @validate_field ( 'name' , instance_of ( str ), Len ( s ) > 0 , error_type = InvalidNameError ) @validate_field ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurfaceError ) @autoclass class House : def __init__ ( self , name , surface = None ): pass which yields: > h = House ( 'sweet home' , 200 ) > h.surface = None # Valid (surface is nonable by signature) > h.name = '' # InvalidNameError > h.surface = 10000 # InvalidSurfaceError Note: if you decorate the class constructor with @validate_arg , the property setters generated by @autoclass will include validation too. from autoclass import autoclass from mini_lambda import s , x , Len from valid8 import validate_arg , instance_of , is_multiple_of , InputValidationError class InvalidNameError ( InputValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurfaceError ( InputValidationError ): help_msg = 'Surface should be a multiple of 100 between 0 and 10000.' @autoclass class House : @validate_arg ( 'name' , instance_of ( str ), Len ( s ) > 0 , error_type = InvalidNameError ) @validate_arg ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurfaceError ) def __init__ ( self , name , surface = None ): pass which yields: > h = House ( 'sweet home' , 200 ) > h.surface = None # Valid (surface is nonable by signature) > h.name = '' # InvalidNameError > h.surface = 10000 # InvalidSurfaceError Of course you can also add PEP484 type checking on top of that, see autoclass documentation for details. attrs \u00b6 valid8 also integrates well with attrs to quickly create small but validated classes: if you decorate a class with @validate_field it will work because attrs generates a compliant class constructor behind the scenes. However WARNING validation will only be called at initial object creation, not at subsequent field modifications! import attr from mini_lambda import s , x , Len from valid8 import validate_field , instance_of , is_multiple_of class InvalidNameError ( ClassFieldValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurfaceError ( ClassFieldValidationError ): help_msg = 'Surface should be a multiple of 100 between 0 and 10000.' @validate_field ( 'name' , instance_of ( str ), Len ( s ) > 0 , error_type = InvalidNameError ) @validate_field ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurfaceError ) @attr.s class House : name = attr . ib () surface = attr . ib ( default = None ) Which we can test: > h = House ( 'sweet home' ) # Valid (surface is nonable by generated signature) > h.name = '' # DOES NOT RAISE InvalidNameError (no setter!) > House ( '' , 10000 ) # InvalidNameError > House ( 'sweet home' , 10000 ) # InvalidSurfaceError As of today attrs does not transform fields into descriptors or properties so there is no way to add validation to field setters. Note that this is actually also the case if you rely on the validation mechanisms built in attrs, as explained here . This feature has been requested here .","title":"valid8 + other tools"},{"location":"valid8_with_other/#valid8-other-tools","text":"","title":"valid8 + other tools"},{"location":"valid8_with_other/#other-validation-styles","text":"The checktypes package provides a way to easily embed your validation requirements as classes, for easy reuse. from valid8 import validate from checktypes import checktype PositiveInt = checktype ( 'PositiveInt' , int , lambda x : x > 0 ) x = 1 validate ( 'x' , x , custom = PositiveInt . validate ) x = - 1 validate ( 'x' , x , custom = PositiveInt . validate ) # ValidationError","title":"Other validation styles"},{"location":"valid8_with_other/#for-functions-and-classes","text":"","title":"For functions and classes"},{"location":"valid8_with_other/#pep484-type-checkers","text":"Although simple type validation may be performed using valid8 , for function inputs/outputs type validation as well as class field type validation you may wish to rely on a proper PEP484 type checker such as enforce or pytypes . The following snippet shows a build_house function with two inputs name and surface , where each input is: validated against the expected type thanks to the PEP484 type checking library ( enforce in this example) further value-validated with valid8 ( len(name) > 0 and surface >= 0 ), with the help of the mini_lambda syntax. # Imports - for type validation from numbers import Integral from typing import Tuple , Optional from enforce import runtime_validation , config config ( dict ( mode = 'covariant' )) # type validation will accept subclasses too # Imports - for value validation from mini_lambda import s , x , Len from valid8 import validate_arg , is_multiple_of , InputValidationError # Define our 2 applicative error types class InvalidNameError ( InputValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurfaceError ( InputValidationError ): help_msg = 'Surface should be a multiple of 100 between 0 and 10000.' # Apply type + value validation @runtime_validation @validate_arg ( 'name' , Len ( s ) > 0 , error_type = InvalidNameError ) @validate_arg ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurfaceError ) def build_house ( name : str , surface : Optional [ Integral ] = None ) \\ -> Tuple [ str , Optional [ Integral ]]: print ( 'Building house... DONE !' ) return name , surface We can test that validation works: > build_house ( 'sweet home' , 200 ) # valid > build_house ( 'sweet home' ) # valid (PEP484 Optional, default=None) > build_house ( '' , 100 ) # InvalidNameError (valid8) > build_house ( 'sweet home' , 10000 ) # InvalidSurfaceError (valid8) > build_house ( 'test' , 100 .1 ) # RuntimeTypeError (enforce) Note concerning PEP484 type validation : how can you make sure to accept both plain old float , int and bool , as well as their numpy equivalents ? Use the handy Real (=float) and Integral (=int) abstract numeric types provided in the numbers built-in module ! They provide an easy way to support both python primitives AND others, e.g. numpy primitives. Unfortunately no equivalent type is provided in the stdlib for booleans, so in valid8 we provide an additional Boolean class supporting numpy, to complete the picture.","title":"PEP484 type checkers"},{"location":"valid8_with_other/#for-classes","text":"","title":"For classes"},{"location":"valid8_with_other/#pyfields","text":"TODO","title":"pyfields"},{"location":"valid8_with_other/#autoclass","text":"valid8 plays well with autoclass to quickly create small but validated classes: If you decorate the whole class with @validate_field the property setters generated by @autoclass will include validation, as expected: from autoclass import autoclass from mini_lambda import s , x , Len from valid8 import validate_arg , instance_of , is_multiple_of class InvalidNameError ( ClassFieldValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurfaceError ( ClassFieldValidationError ): help_msg = 'Surface should be a multiple of 100 between 0 and 10000.' @validate_field ( 'name' , instance_of ( str ), Len ( s ) > 0 , error_type = InvalidNameError ) @validate_field ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurfaceError ) @autoclass class House : def __init__ ( self , name , surface = None ): pass which yields: > h = House ( 'sweet home' , 200 ) > h.surface = None # Valid (surface is nonable by signature) > h.name = '' # InvalidNameError > h.surface = 10000 # InvalidSurfaceError Note: if you decorate the class constructor with @validate_arg , the property setters generated by @autoclass will include validation too. from autoclass import autoclass from mini_lambda import s , x , Len from valid8 import validate_arg , instance_of , is_multiple_of , InputValidationError class InvalidNameError ( InputValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurfaceError ( InputValidationError ): help_msg = 'Surface should be a multiple of 100 between 0 and 10000.' @autoclass class House : @validate_arg ( 'name' , instance_of ( str ), Len ( s ) > 0 , error_type = InvalidNameError ) @validate_arg ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurfaceError ) def __init__ ( self , name , surface = None ): pass which yields: > h = House ( 'sweet home' , 200 ) > h.surface = None # Valid (surface is nonable by signature) > h.name = '' # InvalidNameError > h.surface = 10000 # InvalidSurfaceError Of course you can also add PEP484 type checking on top of that, see autoclass documentation for details.","title":"autoclass"},{"location":"valid8_with_other/#attrs","text":"valid8 also integrates well with attrs to quickly create small but validated classes: if you decorate a class with @validate_field it will work because attrs generates a compliant class constructor behind the scenes. However WARNING validation will only be called at initial object creation, not at subsequent field modifications! import attr from mini_lambda import s , x , Len from valid8 import validate_field , instance_of , is_multiple_of class InvalidNameError ( ClassFieldValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurfaceError ( ClassFieldValidationError ): help_msg = 'Surface should be a multiple of 100 between 0 and 10000.' @validate_field ( 'name' , instance_of ( str ), Len ( s ) > 0 , error_type = InvalidNameError ) @validate_field ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurfaceError ) @attr.s class House : name = attr . ib () surface = attr . ib ( default = None ) Which we can test: > h = House ( 'sweet home' ) # Valid (surface is nonable by generated signature) > h.name = '' # DOES NOT RAISE InvalidNameError (no setter!) > House ( '' , 10000 ) # InvalidNameError > House ( 'sweet home' , 10000 ) # InvalidSurfaceError As of today attrs does not transform fields into descriptors or properties so there is no way to add validation to field setters. Note that this is actually also the case if you rely on the validation mechanisms built in attrs, as explained here . This feature has been requested here .","title":"attrs"},{"location":"why_validation/","text":"Why would I need a validation library ? \u00b6 As for the whole valid8 project, this page is open to contribution, do not hesitate to submit issues or pull requests ! What is validation - goals \u00b6 A variable x , or several variables, are to be used as inputs in a piece of code. These variables might have been received from an external, untrusted/error-prone source such as a caller code, a cli, web form, a web service client, data files, etc. Validation is the process of handling bad values so as to make the sender of these bad values aware that they are bad , and aware of why they are bad. This is typically done with explicit, user-friendly error messages sent if anything went wrong during validation (even the unexpected!). What is key here is to remember that the caller's primary concern is first to know what was validated and why ( intent / requirement for good data ), then the means / inner details about e.g. what library you are using to validate his data, and its particular error message. stop processing early , so that the code does not get an opportunity to fall into a harder-to-detect bug, or so as to avoid performing a computationally expensive task if it is useless. This is also called defensive programming, or offensive programming . How do you write validation today \u00b6 If you are an experienced coder, you probably already implement validation in a number of ways, whether to check the variables' types and/or values. Below we present the main styles. Implicit / 'pythonic' way \u00b6 The good old \"better ask for forgiveness than for permission\" : do not validate, just try to use the variable and see if it works. If something goes wrong, wrap it with a more appropriate user-friendly exception. def pythonic_function ( x ): try : # try to use x as if it were valid ... except < ExceptionType > as e : # raise the appropriate error message based on the caught exception raise < AppropriateException >. with_traceback ( e . __traceback__ ) else : # here we can use x safely ... # yes this is a valid construct :) you can use it to distinguish the lines # of code that may raise an error from those that may not. In practice it # is rarely used, you would put everything in the try block. This style has the advantage of being compact but has two major drawbacks: useless long-running operations : if the exception happens late in the code, that my lead to a long waiting time for the caller before it gets notified undetected bad data / 'crap in-crap out' : for scientific applications such as machine learning, it might be that invalid data goes all the way through the code until you get a result, without throwing a single exception. It might even be hard to see that the output is actually completely wrong, until much further in the application lifecycle. (thanks source for the try-except-else construct ) Explicit / 'traditional' way \u00b6 With this style you explicitly validate the variables before using them. To that end you typically rely on a blend of custom validation statements such as x > 0 , that might contain function calls, such as sqrt(x) > 0.5 . These functions might raise exceptions on some edge cases ( sqrt(-1) ) reused user-made or third party validation functions , such as isfinite(x) or assert_array_equal(x, ref) . Many, many such functions are available out there from various libraries - here is an extract . There are two predominant styles out there: boolean testers such as isfinite : they return True in case of success and False in case of failure, and therefore do not provide any details about the failure when they fail. Sometimes they continue to raise exceptions on edge cases ( isfinite(None) , isfinite(1+1j) ). failure raisers such as check_uniform_sampling or assert_array_equal : they do not return anything in case of success, but raise exceptions with details in case of failure. Blending all of the above to get a consistent validation process is 'the art of the master blender', a case-by-case story, where you typically wrap everything in a master try/except since even boolean testers and custom validation statements can raise exceptions ( sqrt(x) > 0.5 raises an exception if x is -1 ). For example: def conservative_function ( x ): try : if isfinite ( x ) and sqrt ( x ) < 10 : # <- even these can raise exceptions! raise < AppropriateException > check_uniform_sampling ( x ) except Exception as e : # raise the appropriate error message based on the caught exception raise < AppropriateException > from e # here we can use x safely ... Also note that it is not easy to combine failure raisers together, or with boolean testers , in a boolean logic style. For example below we perform a virtual or between two failure raisers : def conservative_function ( x ): try : check_uniform_sampling ( x ) except Exception as e : # First asserter failed, let's try the other one try : assert_array_equal ( x , ref ) except Exception as f : # raise the appropriate error message based on the caught exception raise < AppropriateException > from e # or f ? # here we can use x safely ... Special case of assert \u00b6 assert could be thought of as a good tool to perform validation: def function_with_assert ( x ): assert < validation_statement_on_x > , \"invalid x : ...\" # here we can use x safely However it has three major drawbacks that make it unusable in practice: the error raised in case of failure is an AssertionError , which is usually not the type of error you want to raise if you want unique error types for each kind of applicative validation, and it lacks customizability if <validation_statement_on_x> raises exceptions, they will be raised directly and not wrapped by the AssertionError and used as the __cause__ : that might lead to several exception types for the same applicative intent assert can be disabled at application-level: the statement won't be executed if the code is executed in optimized mode, as explained in the documentation . To quote this source \"Many people use asserts as a quick and easy way to raise an exception if an argument is given the wrong value. But this is wrong, dangerously wrong, for two reasons. The first is that AssertionError is usually the wrong error to give when testing function arguments. But, and more dangerously, there's a twist with assert: it can be compiled away and never executed, if you run Python with the -O or -OO optimization flags [...]\" . In addition here again, note that if the <validate> function itself may raise Exceptions, you can end up with two kind of exceptions raised. What are we missing today for general-purpose validation \u00b6 We saw in the examples above that implicit validation and asserts are not satisfying, therefore we are left with explicit handcrafted validation . What are the drawbacks as of today, where could we make progress ? Compactness / readability \u00b6 It takes far too many lines of code to implement explicit handcrafted validation . This is a pity, as it does not encourage developers to insert validation in their code, and it makes the code less readable/maintainable. Having a solution to write most validation tasks in one or two lines of code would completely change the game: people would actually do it more often (and with actual pleasure doing it), and hopefully the amount of annoying cryptic exceptions we receive daily from our favorite opensource libraries would reduce significantly. If this goal is reached, this would improve quality of small open source projects over time. Indeed, with limited resources (time+human), validation is often skipped, which is not the case for \"more serious\" projects with a full team of developers. Exceptions consistency \u00b6 There are many choices left in explicit handcrafted validation concerning the exception that is raised in case of validation failure. This may make any application/library rapidly lack consistency except for highly skilled coders. The following points in particular need to be handled consistently... but do we take the time to do it (especially when under pressure for delivery)? validation root exception types are not standard across developers and even inside a code base. It is recommended to use TypeError for type validation and ValueError for value validation, or any subclass of those, but at the same time we might wish to have a common ValidationError type holding validation context and intent ; so we have to use multiple inheritance to do this right when failure comes from a caught inner exception, the __cause__ flag of the wrapper validation exception would need to be correctly set (or raise e from f ), everywhere, consistently if we wish validation exceptions to easily be associated with error codes when exchanged with the rest of the application (web front-end, etc.), for internationalization (i18n) purposes, the best practice in python would be to create one exception class per type of error, so that an exception class = an error code. We can do this, but here again we have to think about it everywhere to keep consistency. even in plain english, validation messages should be user-friendly otherwise the user may struggle some time to understand why the value he entered was not correct. This can be mitigated if we have a global error code handler at the top of our application, that re-writes the appropriate internationalized message before sending it back to the user. Easy blending to reuse base validation functions \u00b6 We saw above that with explicit handcrafted validation , we often end up reusing functions that are written in two incompatible styles ( boolean testers and failure raisers ), not to mention our own custom validation statements . Providing ways to easily blend those would encourage a larger reuse of privately made or community-grown validation libraries such as these . Less boring copy/paste, more leveraging existing good work. Functions and classes \u00b6 Function inputs and outputs as well as class fields could be validated at function/class definition directly, instead of inside the function body / attribute setter. Note on entry-point validation: Cli, Schema and Forms \u00b6 If you are sure that nobody will access your code directly (e.g. you do not share it as a library), you may wish to only perform value validation directly at the entry point, whether it is a command line interface, a web form or a soap/rest webservice in json or xml. This is perfectly fine and libraries providing the entry-point often come with validators/decorators bundled inside, such as in click or django . See here . However as soon as you wish to also share your code as a library, you end up needing to maintain two validation frameworks: one for the entry points, and one for the library. There is no easy solution to solve this problem: you may wish to only perform validation in you core library functions, or core library's API. This can be enhanced by the creation of 'validated objects' for example using autoclass , so that you do not re-validate in every function the object contents once it has been created you may need to still perform entry point-validation, may it only for the reason that you share a schema as a contract with your customers (through swagger or equivalent).","title":"Why validation"},{"location":"why_validation/#why-would-i-need-a-validation-library","text":"As for the whole valid8 project, this page is open to contribution, do not hesitate to submit issues or pull requests !","title":"Why would I need a validation library ?"},{"location":"why_validation/#what-is-validation-goals","text":"A variable x , or several variables, are to be used as inputs in a piece of code. These variables might have been received from an external, untrusted/error-prone source such as a caller code, a cli, web form, a web service client, data files, etc. Validation is the process of handling bad values so as to make the sender of these bad values aware that they are bad , and aware of why they are bad. This is typically done with explicit, user-friendly error messages sent if anything went wrong during validation (even the unexpected!). What is key here is to remember that the caller's primary concern is first to know what was validated and why ( intent / requirement for good data ), then the means / inner details about e.g. what library you are using to validate his data, and its particular error message. stop processing early , so that the code does not get an opportunity to fall into a harder-to-detect bug, or so as to avoid performing a computationally expensive task if it is useless. This is also called defensive programming, or offensive programming .","title":"What is validation - goals"},{"location":"why_validation/#how-do-you-write-validation-today","text":"If you are an experienced coder, you probably already implement validation in a number of ways, whether to check the variables' types and/or values. Below we present the main styles.","title":"How do you write validation today"},{"location":"why_validation/#implicit-pythonic-way","text":"The good old \"better ask for forgiveness than for permission\" : do not validate, just try to use the variable and see if it works. If something goes wrong, wrap it with a more appropriate user-friendly exception. def pythonic_function ( x ): try : # try to use x as if it were valid ... except < ExceptionType > as e : # raise the appropriate error message based on the caught exception raise < AppropriateException >. with_traceback ( e . __traceback__ ) else : # here we can use x safely ... # yes this is a valid construct :) you can use it to distinguish the lines # of code that may raise an error from those that may not. In practice it # is rarely used, you would put everything in the try block. This style has the advantage of being compact but has two major drawbacks: useless long-running operations : if the exception happens late in the code, that my lead to a long waiting time for the caller before it gets notified undetected bad data / 'crap in-crap out' : for scientific applications such as machine learning, it might be that invalid data goes all the way through the code until you get a result, without throwing a single exception. It might even be hard to see that the output is actually completely wrong, until much further in the application lifecycle. (thanks source for the try-except-else construct )","title":"Implicit / 'pythonic' way"},{"location":"why_validation/#explicit-traditional-way","text":"With this style you explicitly validate the variables before using them. To that end you typically rely on a blend of custom validation statements such as x > 0 , that might contain function calls, such as sqrt(x) > 0.5 . These functions might raise exceptions on some edge cases ( sqrt(-1) ) reused user-made or third party validation functions , such as isfinite(x) or assert_array_equal(x, ref) . Many, many such functions are available out there from various libraries - here is an extract . There are two predominant styles out there: boolean testers such as isfinite : they return True in case of success and False in case of failure, and therefore do not provide any details about the failure when they fail. Sometimes they continue to raise exceptions on edge cases ( isfinite(None) , isfinite(1+1j) ). failure raisers such as check_uniform_sampling or assert_array_equal : they do not return anything in case of success, but raise exceptions with details in case of failure. Blending all of the above to get a consistent validation process is 'the art of the master blender', a case-by-case story, where you typically wrap everything in a master try/except since even boolean testers and custom validation statements can raise exceptions ( sqrt(x) > 0.5 raises an exception if x is -1 ). For example: def conservative_function ( x ): try : if isfinite ( x ) and sqrt ( x ) < 10 : # <- even these can raise exceptions! raise < AppropriateException > check_uniform_sampling ( x ) except Exception as e : # raise the appropriate error message based on the caught exception raise < AppropriateException > from e # here we can use x safely ... Also note that it is not easy to combine failure raisers together, or with boolean testers , in a boolean logic style. For example below we perform a virtual or between two failure raisers : def conservative_function ( x ): try : check_uniform_sampling ( x ) except Exception as e : # First asserter failed, let's try the other one try : assert_array_equal ( x , ref ) except Exception as f : # raise the appropriate error message based on the caught exception raise < AppropriateException > from e # or f ? # here we can use x safely ...","title":"Explicit / 'traditional' way"},{"location":"why_validation/#special-case-of-assert","text":"assert could be thought of as a good tool to perform validation: def function_with_assert ( x ): assert < validation_statement_on_x > , \"invalid x : ...\" # here we can use x safely However it has three major drawbacks that make it unusable in practice: the error raised in case of failure is an AssertionError , which is usually not the type of error you want to raise if you want unique error types for each kind of applicative validation, and it lacks customizability if <validation_statement_on_x> raises exceptions, they will be raised directly and not wrapped by the AssertionError and used as the __cause__ : that might lead to several exception types for the same applicative intent assert can be disabled at application-level: the statement won't be executed if the code is executed in optimized mode, as explained in the documentation . To quote this source \"Many people use asserts as a quick and easy way to raise an exception if an argument is given the wrong value. But this is wrong, dangerously wrong, for two reasons. The first is that AssertionError is usually the wrong error to give when testing function arguments. But, and more dangerously, there's a twist with assert: it can be compiled away and never executed, if you run Python with the -O or -OO optimization flags [...]\" . In addition here again, note that if the <validate> function itself may raise Exceptions, you can end up with two kind of exceptions raised.","title":"Special case of assert"},{"location":"why_validation/#what-are-we-missing-today-for-general-purpose-validation","text":"We saw in the examples above that implicit validation and asserts are not satisfying, therefore we are left with explicit handcrafted validation . What are the drawbacks as of today, where could we make progress ?","title":"What are we missing today for general-purpose validation"},{"location":"why_validation/#compactness-readability","text":"It takes far too many lines of code to implement explicit handcrafted validation . This is a pity, as it does not encourage developers to insert validation in their code, and it makes the code less readable/maintainable. Having a solution to write most validation tasks in one or two lines of code would completely change the game: people would actually do it more often (and with actual pleasure doing it), and hopefully the amount of annoying cryptic exceptions we receive daily from our favorite opensource libraries would reduce significantly. If this goal is reached, this would improve quality of small open source projects over time. Indeed, with limited resources (time+human), validation is often skipped, which is not the case for \"more serious\" projects with a full team of developers.","title":"Compactness / readability"},{"location":"why_validation/#exceptions-consistency","text":"There are many choices left in explicit handcrafted validation concerning the exception that is raised in case of validation failure. This may make any application/library rapidly lack consistency except for highly skilled coders. The following points in particular need to be handled consistently... but do we take the time to do it (especially when under pressure for delivery)? validation root exception types are not standard across developers and even inside a code base. It is recommended to use TypeError for type validation and ValueError for value validation, or any subclass of those, but at the same time we might wish to have a common ValidationError type holding validation context and intent ; so we have to use multiple inheritance to do this right when failure comes from a caught inner exception, the __cause__ flag of the wrapper validation exception would need to be correctly set (or raise e from f ), everywhere, consistently if we wish validation exceptions to easily be associated with error codes when exchanged with the rest of the application (web front-end, etc.), for internationalization (i18n) purposes, the best practice in python would be to create one exception class per type of error, so that an exception class = an error code. We can do this, but here again we have to think about it everywhere to keep consistency. even in plain english, validation messages should be user-friendly otherwise the user may struggle some time to understand why the value he entered was not correct. This can be mitigated if we have a global error code handler at the top of our application, that re-writes the appropriate internationalized message before sending it back to the user.","title":"Exceptions consistency"},{"location":"why_validation/#easy-blending-to-reuse-base-validation-functions","text":"We saw above that with explicit handcrafted validation , we often end up reusing functions that are written in two incompatible styles ( boolean testers and failure raisers ), not to mention our own custom validation statements . Providing ways to easily blend those would encourage a larger reuse of privately made or community-grown validation libraries such as these . Less boring copy/paste, more leveraging existing good work.","title":"Easy blending to reuse base validation functions"},{"location":"why_validation/#functions-and-classes","text":"Function inputs and outputs as well as class fields could be validated at function/class definition directly, instead of inside the function body / attribute setter.","title":"Functions and classes"},{"location":"why_validation/#note-on-entry-point-validation-cli-schema-and-forms","text":"If you are sure that nobody will access your code directly (e.g. you do not share it as a library), you may wish to only perform value validation directly at the entry point, whether it is a command line interface, a web form or a soap/rest webservice in json or xml. This is perfectly fine and libraries providing the entry-point often come with validators/decorators bundled inside, such as in click or django . See here . However as soon as you wish to also share your code as a library, you end up needing to maintain two validation frameworks: one for the entry points, and one for the library. There is no easy solution to solve this problem: you may wish to only perform validation in you core library functions, or core library's API. This can be enhanced by the creation of 'validated objects' for example using autoclass , so that you do not re-validate in every function the object contents once it has been created you may need to still perform entry point-validation, may it only for the reason that you share a schema as a contract with your customers (through swagger or equivalent).","title":"Note on entry-point validation: Cli, Schema and Forms"},{"location":"examples/example1/","text":"Example 1 - x is a positive integer \u00b6 1- Example values to validate \u00b6 # Valid x = 0 x = 100 # Invalid x = 'foo' # wrong type x = 1.0 # wrong type x = - 1 # negative 2- Inline validation \u00b6 validate \u00b6 from valid8 import validate validate ( 'x' , x , instance_of = Integral , min_value = 0 ) with validator \u00b6 from valid8 import validator with validator ( 'x' , x , instance_of = Integral ) as v : v . alid = x >= 0 3- Functions/classes validation \u00b6 Principles \u00b6 We can either use the built-in gt function to check for positiveness here, or the mini-lambda function x >= 0 (or a plain old lambda/function). Function input \u00b6 with built-in: from valid8 import validate_arg , instance_of , gt @validate_arg ( 'x' , instance_of ( Integral ), gt ( 0 )) def my_function ( x ): pass or with mini-lambda from mini_lambda import x from valid8 import validate_arg , instance_of @validate_arg ( 'x' , instance_of ( Integral ), x >= 0 ) def my_function ( x ): pass Function output \u00b6 with built-in: from valid8 import validate_out , instance_of , gt @validate_out ( instance_of ( Integral ), gt ( 0 )) def my_function2 (): return - 1 or with mini-lambda from mini_lambda import x from valid8 import validate_out , instance_of @validate_out ( instance_of ( Integral ), x >= 0 ) def my_function2 (): return - 1 Function ios \u00b6 With validate_io you can check several inputs+output in the same decorator, but no customization is possible. with built-in: from valid8 import validate_io , instance_of , gt @validate_io ( x = [ instance_of ( Integral ), gt ( 0 )]) def my_function3 ( x ): pass or with mini-lambda from mini_lambda import x from valid8 import validate_io , instance_of @validate_io ( x = [ instance_of ( Integral ), x >= 0 ]) def my_function3 ( x ): pass Class fields \u00b6 In the examples below the class fields are defined as constructor arguments but this also works if they are defined as class descriptors/properties, and is compliant with autoclass and attrs using built-in gt : from valid8 import validate_field , instance_of , gt @validate_field ( 'x' , instance_of ( Integral ), gt ( 0 )) class Foo : def __init__ ( self , x ): self . x = x or with mini-lambda from mini_lambda import x from valid8 import validate_field , instance_of @validate_field ( 'x' , instance_of ( Integral ), x >= 0 ) class Foo : def __init__ ( self , x ): self . x = x With PEP484 \u00b6 In the above code samples the type was checked by instance_of(Integral) in the decorators, but you could also rather declare a type hint in the function/class signature and rely on a PEP484 checker library , that makes the decorator much more compact and focused on value validation only. For example for to check a function input: from pytypes import typechecked from mini_lambda import x from valid8 import validate_arg @typechecked @validate_arg ( 'x' , x >= 0 ) def my_function ( x : Integral ): # <- type hint in signature pass 4- Variants \u00b6 This example could be easily modified so that floating point integers are accepted, such as 1.0 . The way to do it is very similar to example 2 : you should validate that type is Real instead of Integral , and that x == int(x) . You can also do it with a custom function like in example 3 .","title":"Example 1"},{"location":"examples/example1/#example-1-x-is-a-positive-integer","text":"","title":"Example 1 - x is a positive integer"},{"location":"examples/example1/#1-example-values-to-validate","text":"# Valid x = 0 x = 100 # Invalid x = 'foo' # wrong type x = 1.0 # wrong type x = - 1 # negative","title":"1- Example values to validate"},{"location":"examples/example1/#2-inline-validation","text":"","title":"2- Inline validation"},{"location":"examples/example1/#validate","text":"from valid8 import validate validate ( 'x' , x , instance_of = Integral , min_value = 0 )","title":"validate"},{"location":"examples/example1/#with-validator","text":"from valid8 import validator with validator ( 'x' , x , instance_of = Integral ) as v : v . alid = x >= 0","title":"with validator"},{"location":"examples/example1/#3-functionsclasses-validation","text":"","title":"3- Functions/classes validation"},{"location":"examples/example1/#principles","text":"We can either use the built-in gt function to check for positiveness here, or the mini-lambda function x >= 0 (or a plain old lambda/function).","title":"Principles"},{"location":"examples/example1/#function-input","text":"with built-in: from valid8 import validate_arg , instance_of , gt @validate_arg ( 'x' , instance_of ( Integral ), gt ( 0 )) def my_function ( x ): pass or with mini-lambda from mini_lambda import x from valid8 import validate_arg , instance_of @validate_arg ( 'x' , instance_of ( Integral ), x >= 0 ) def my_function ( x ): pass","title":"Function input"},{"location":"examples/example1/#function-output","text":"with built-in: from valid8 import validate_out , instance_of , gt @validate_out ( instance_of ( Integral ), gt ( 0 )) def my_function2 (): return - 1 or with mini-lambda from mini_lambda import x from valid8 import validate_out , instance_of @validate_out ( instance_of ( Integral ), x >= 0 ) def my_function2 (): return - 1","title":"Function output"},{"location":"examples/example1/#function-ios","text":"With validate_io you can check several inputs+output in the same decorator, but no customization is possible. with built-in: from valid8 import validate_io , instance_of , gt @validate_io ( x = [ instance_of ( Integral ), gt ( 0 )]) def my_function3 ( x ): pass or with mini-lambda from mini_lambda import x from valid8 import validate_io , instance_of @validate_io ( x = [ instance_of ( Integral ), x >= 0 ]) def my_function3 ( x ): pass","title":"Function ios"},{"location":"examples/example1/#class-fields","text":"In the examples below the class fields are defined as constructor arguments but this also works if they are defined as class descriptors/properties, and is compliant with autoclass and attrs using built-in gt : from valid8 import validate_field , instance_of , gt @validate_field ( 'x' , instance_of ( Integral ), gt ( 0 )) class Foo : def __init__ ( self , x ): self . x = x or with mini-lambda from mini_lambda import x from valid8 import validate_field , instance_of @validate_field ( 'x' , instance_of ( Integral ), x >= 0 ) class Foo : def __init__ ( self , x ): self . x = x","title":"Class fields"},{"location":"examples/example1/#with-pep484","text":"In the above code samples the type was checked by instance_of(Integral) in the decorators, but you could also rather declare a type hint in the function/class signature and rely on a PEP484 checker library , that makes the decorator much more compact and focused on value validation only. For example for to check a function input: from pytypes import typechecked from mini_lambda import x from valid8 import validate_arg @typechecked @validate_arg ( 'x' , x >= 0 ) def my_function ( x : Integral ): # <- type hint in signature pass","title":"With PEP484"},{"location":"examples/example1/#4-variants","text":"This example could be easily modified so that floating point integers are accepted, such as 1.0 . The way to do it is very similar to example 2 : you should validate that type is Real instead of Integral , and that x == int(x) . You can also do it with a custom function like in example 3 .","title":"4- Variants"},{"location":"examples/example2/","text":"Example 2 - s is a lowercase non-empty string \u00b6 1- Example values to validate \u00b6 # Valid s = 'foo' s = 'foo_123' # Invalid s = 1.1 # wrong type s = '' # empty string s = 'fOO' # not-lowercase 2- Inline validation \u00b6 validate \u00b6 We use a trick here since validate does not provide built-in parameters to check that a string is lowercase. We therefore can check equality with the lowercase version of the string ( equals=s.lower() ). This will not lead to a very friendly error message, but remember that you can customize it . from valid8 import validate validate ( 's' , s , instance_of = str ) validate ( 's' , s , min_len = 1 , equals = s . lower ()) You can remark in the above that we have to split the validation in two steps. If we don't do this, then s.lower() may raise an exception such as a AttributeError , that won't be captured and wrapped correctly by ValidationError . In that case users will not get contextual information (name, custom error message...). A much better way to do this is to use the unbound class function str.islower as a custom function, it will be more readable: from valid8 import validate validate ( 's' , s , instance_of = str , min_len = 1 , custom = str . islower ) Remember that most functions available on objects can be used as unbound class functions like this! This opens a lot of possibilities to validate . Also note that you can provide a list of functions to the custom= argument, and that it accepts lambda functions like the decorators: from valid8 import validate # we create a custom mini_lambda variable, since the name 's' is already used from mini_lambda import InputVar txt = InputVar ( 'txt' , str ) validate ( 's' , s , instance_of = str , min_len = 1 , custom = txt . islower ()) with validator \u00b6 from valid8 import validator with validator ( 's' , s , instance_of = str ) as v : v . alid = ( len ( s ) > 0 ) and s . islower () 3- Functions/classes validation \u00b6 Principles \u00b6 Type can be checked with built-in instance_of Length can be checked with built-in minlen or mini-lambda Len(s) > 0 or custom functions There is no built-in function to check that s is lowercase yet, but as we saw above we can use the unbound class function str.islower or the mini-lambda s.islower() . We will not show all combinations here (please refer to example 1 for all kind of decorators), only a few examples: Function input \u00b6 with pure built-in and stdlib: from valid8 import validate_arg , instance_of , minlen @validate_arg ( 's' , instance_of ( str ), minlen ( 1 ), str . islower ) def my_function ( s ): pass or with pure mini-lambda from mini_lambda import s , Len from valid8 import validate_arg , instance_of @validate_arg ( 's' , instance_of ( str ), Len ( s ) > 0 , s . islower ()) def my_function ( s ): pass Class fields \u00b6 In the examples below the class fields are defined as constructor arguments but this also works if they are defined as class descriptors/properties, and is compliant with autoclass and attrs with pure built-in and stdlib: from valid8 import validate_field , instance_of , minlen @validate_field ( 's' , instance_of ( str ), minlen ( 1 ), str . islower ) class Foo : def __init__ ( self , s ): self . s = s or with pure mini-lambda from mini_lambda import s , Len from valid8 import validate_field , instance_of @validate_field ( 's' , instance_of ( str ), Len ( s ) > 0 , s . islower ()) class Foo : def __init__ ( self , s ): self . s = s With PEP484 \u00b6 In the above code samples the type was checked by instance_of(str) in the decorator, but you could also rather declare a type hint in the function/class signature and rely on a PEP484 checker library , that makes the decorator much more compact and focused on value validation only: from pytypes import typechecked from mini_lambda import s , Len from valid8 import validate_arg @typechecked @validate_arg ( 's' , Len ( s ) > 0 , s . islower ()) def my_function ( s : str ): # <- type hint in signature pass 4- Variants \u00b6 This example could be easily modified with regular expression validation for the string. To that end you could either * create your own custom function * use an existing regular expression validation function generator. For example: import re # basic regex to check that there is one @ and a dot in the second part EMAIL_REGEX = re . compile ( '[^@]+@[^@]+\\.[^@]+' ) # you can now use 'EMAIL_REGEX.match' in a custom function or lambda, # as long as that returns True or None in case of success validate ( 's' , s , instance_of = str , custom = lambda s : bool ( EMAIL_REGEX . match ( s )))","title":"Example 2"},{"location":"examples/example2/#example-2-s-is-a-lowercase-non-empty-string","text":"","title":"Example 2 - s is a lowercase non-empty string"},{"location":"examples/example2/#1-example-values-to-validate","text":"# Valid s = 'foo' s = 'foo_123' # Invalid s = 1.1 # wrong type s = '' # empty string s = 'fOO' # not-lowercase","title":"1- Example values to validate"},{"location":"examples/example2/#2-inline-validation","text":"","title":"2- Inline validation"},{"location":"examples/example2/#validate","text":"We use a trick here since validate does not provide built-in parameters to check that a string is lowercase. We therefore can check equality with the lowercase version of the string ( equals=s.lower() ). This will not lead to a very friendly error message, but remember that you can customize it . from valid8 import validate validate ( 's' , s , instance_of = str ) validate ( 's' , s , min_len = 1 , equals = s . lower ()) You can remark in the above that we have to split the validation in two steps. If we don't do this, then s.lower() may raise an exception such as a AttributeError , that won't be captured and wrapped correctly by ValidationError . In that case users will not get contextual information (name, custom error message...). A much better way to do this is to use the unbound class function str.islower as a custom function, it will be more readable: from valid8 import validate validate ( 's' , s , instance_of = str , min_len = 1 , custom = str . islower ) Remember that most functions available on objects can be used as unbound class functions like this! This opens a lot of possibilities to validate . Also note that you can provide a list of functions to the custom= argument, and that it accepts lambda functions like the decorators: from valid8 import validate # we create a custom mini_lambda variable, since the name 's' is already used from mini_lambda import InputVar txt = InputVar ( 'txt' , str ) validate ( 's' , s , instance_of = str , min_len = 1 , custom = txt . islower ())","title":"validate"},{"location":"examples/example2/#with-validator","text":"from valid8 import validator with validator ( 's' , s , instance_of = str ) as v : v . alid = ( len ( s ) > 0 ) and s . islower ()","title":"with validator"},{"location":"examples/example2/#3-functionsclasses-validation","text":"","title":"3- Functions/classes validation"},{"location":"examples/example2/#principles","text":"Type can be checked with built-in instance_of Length can be checked with built-in minlen or mini-lambda Len(s) > 0 or custom functions There is no built-in function to check that s is lowercase yet, but as we saw above we can use the unbound class function str.islower or the mini-lambda s.islower() . We will not show all combinations here (please refer to example 1 for all kind of decorators), only a few examples:","title":"Principles"},{"location":"examples/example2/#function-input","text":"with pure built-in and stdlib: from valid8 import validate_arg , instance_of , minlen @validate_arg ( 's' , instance_of ( str ), minlen ( 1 ), str . islower ) def my_function ( s ): pass or with pure mini-lambda from mini_lambda import s , Len from valid8 import validate_arg , instance_of @validate_arg ( 's' , instance_of ( str ), Len ( s ) > 0 , s . islower ()) def my_function ( s ): pass","title":"Function input"},{"location":"examples/example2/#class-fields","text":"In the examples below the class fields are defined as constructor arguments but this also works if they are defined as class descriptors/properties, and is compliant with autoclass and attrs with pure built-in and stdlib: from valid8 import validate_field , instance_of , minlen @validate_field ( 's' , instance_of ( str ), minlen ( 1 ), str . islower ) class Foo : def __init__ ( self , s ): self . s = s or with pure mini-lambda from mini_lambda import s , Len from valid8 import validate_field , instance_of @validate_field ( 's' , instance_of ( str ), Len ( s ) > 0 , s . islower ()) class Foo : def __init__ ( self , s ): self . s = s","title":"Class fields"},{"location":"examples/example2/#with-pep484","text":"In the above code samples the type was checked by instance_of(str) in the decorator, but you could also rather declare a type hint in the function/class signature and rely on a PEP484 checker library , that makes the decorator much more compact and focused on value validation only: from pytypes import typechecked from mini_lambda import s , Len from valid8 import validate_arg @typechecked @validate_arg ( 's' , Len ( s ) > 0 , s . islower ()) def my_function ( s : str ): # <- type hint in signature pass","title":"With PEP484"},{"location":"examples/example2/#4-variants","text":"This example could be easily modified with regular expression validation for the string. To that end you could either * create your own custom function * use an existing regular expression validation function generator. For example: import re # basic regex to check that there is one @ and a dot in the second part EMAIL_REGEX = re . compile ( '[^@]+@[^@]+\\.[^@]+' ) # you can now use 'EMAIL_REGEX.match' in a custom function or lambda, # as long as that returns True or None in case of success validate ( 's' , s , instance_of = str , custom = lambda s : bool ( EMAIL_REGEX . match ( s )))","title":"4- Variants"},{"location":"examples/example3/","text":"Example 3 - t is a custom tuple \u00b6 For example t is a tuple that contains a float between 0 and 1 and a lowercase trigram (three-letter lowercase string). 1- Example values to validate \u00b6 # Valid t = ( 0.2 , 'foo' ) t = ( 1.0 , 'abc' ) t = ( 0 , 'foo' ) # we accept integers # Invalid t = 1.1 # wrong type (not a tuple) t = ( 0.2 , 'foo' , True ) # wrong size (size 3) t = ( '1.0' , 'foo' ) # wrong type ('1.0' is not a float) t = ( 1.1 , 'foo' ) # wrong value (1.1 is not between 0 and 1) t = ( 1.0 , False ) # wrong type (False is not a string) t = ( 0.5 , 'a' ) # wrong value ('a' is not of size 3) t = ( 0.5 , 'AAA' ) # wrong value ('AAA' is not lowercase) 2- Inline validation \u00b6 validate + built-ins \u00b6 validate can not perform everything at once without a custom validation function , but you can easily validate each element: from valid8 import validate validate ( 't' , t , instance_of = tuple , length = 2 ) validate ( 't[0]' , t [ 0 ], instance_of = Real , min_value = 0 , max_value = 1 ) validate ( 't[1]' , t [ 1 ], instance_of = str , length = 3 , custom = str . islower ) Note that we prefer to user custom=str.islower to check if a string is lowercase, rather than equals=s.lower() , as explained in previous example 2 . with validator + built-ins \u00b6 It is relatively straightforward to validate both t and its contents either with a pure \"boolean test\" approach (where we use instance_of instead of isinstance so that valid8 can distinguish between TypeError and ValueError ): from valid8 import validator , instance_of with validator ( 't' , t , instance_of = tuple ) as v : v . alid = len ( t ) == 2 \\ and instance_of ( t [ 0 ], Real ) and ( 0 <= t [ 0 ] <= 1 ) \\ and instance_of ( t [ 1 ], str ) and len ( t [ 1 ]) == 3 and t [ 1 ] . islower () or with a \"failure raising\" approach, less compact but with more explicit error messages: from valid8 import validation with validation ( 't' , t , instance_of = tuple ): # the tuple should be of length 2 if len ( t ) != 2 : raise ValueError ( 'tuple length should be 2, found ' + str ( t )) # the first element is a float between 0 and 1 if not isinstance ( t [ 0 ], Real ): raise TypeError ( 'first elt should be a Real, found ' + str ( t [ 0 ])) if not ( 0 <= t [ 0 ] <= 1 ): raise ValueError ( 'first elt should be between 0 and 1,found ' + str ( t [ 0 ])) # the second element is a lowercase string of size 3 if not isinstance ( t [ 1 ], str ): raise TypeError ( 'second elt should be a string, found ' + str ( t [ 1 ])) if not ( len ( t [ 1 ]) == 3 and t [ 1 ] . islower ()): raise ValueError ( 'second elt should be a lowercase string of length 3,' 'found ' + str ( t [ 1 ])) 3- Functions/classes validation \u00b6 Principles \u00b6 Type can be checked with built-in instance_of Length can be checked with built-in has_length or mini-lambda Len(t) == 2 or custom functions There is no built-in function to check that s is lowercase yet, but as we saw above we can use the unbound class function str.islower or the mini-lambda s.islower() . We will not show all combinations here (please refer to example 1 for all kind of decorators), only a few examples: Function input \u00b6 With pure built-in and stdlib. Note: we have to use on_each_ to map validation functions to each element of the tuple: from valid8 import validate_arg , instance_of , has_length , on_each_ , and_ , between @validate_arg ( 't' , instance_of ( tuple ), has_length ( 2 ), on_each_ ( # the first element is a float between 0 and 1 and_ ( instance_of ( Real ), between ( 0 , 1 )), # the 2d element is a lowercase string of len 3 and_ ( instance_of ( str ), has_length ( 3 ), str . islower ), )) def my_function ( t ): pass With pure mini-lambda. Note that mini-lambda allows you to directly access the inner elements inside the tuple with traditional indexing: from mini_lambda import InputVar , Len from valid8 import validate_arg , instance_of from valid8.validation_lib.mini_lambda import Instance_of # we need a mini_lambda variable named 't' t = InputVar ( 't' , tuple ) @validate_arg ( 't' , instance_of ( tuple ), Len ( t ) == 2 , # the first element is a float between 0 and 1 Instance_of ( t [ 0 ], Real ), ( 0 <= t [ 0 ]) & ( t [ 0 ] <= 1 ), # the 2d element is a lowercase string of len 3 Instance_of ( t [ 1 ], str ), Len ( t [ 1 ]) == 3 , t [ 1 ] . islower () ) def my_function ( t ): pass Also note that here as in all previous examples we want to use instance_of instead of isinstance in order to raise the correct TypeError . But instance_of is a standard function, it is not composable with mini-lambda expressions such as t[0] . Therefore we use the mini-lambda version of instance_of provided in this package, named Instance_of . This allows us to write type tests for sub-elements in the tuple, for example Instance_of(t[0], Real) . Class fields \u00b6 In the examples below the class fields are defined as constructor arguments but this also works if they are defined as class descriptors/properties, and is compliant with autoclass and attrs with pure built-in and stdlib: from valid8 import validate_field , from valid8 import instance_of , has_length , on_each_ , and_ , between @validate_field ( 't' , instance_of ( tuple ), has_length ( 2 ), on_each_ ( # the first element is a float between 0 and 1 and_ ( instance_of ( Real ), between ( 0 , 1 )), # the 2d element is a lowercase string of len 3 and_ ( instance_of ( str ), has_length ( 3 ), str . islower ), )) class Foo : def __init__ ( self , t ): self . t = t or with pure mini-lambda from mini_lambda import InputVar , Len from valid8 import validate_field , instance_of from valid8.validation_lib.mini_lambda import Instance_of # we need a mini_lambda variable named 't' t = InputVar ( 't' , tuple ) @validate_field ( 't' , instance_of ( tuple ), Len ( t ) == 2 , # the first element is a float between 0 and 1 Instance_of ( t [ 0 ], Real ), ( 0 <= t [ 0 ]) & ( t [ 0 ] <= 1 ), # the 2d element is a lowercase string of len 3 Instance_of ( t [ 1 ], str ), Len ( t [ 1 ]) == 3 , t [ 1 ] . islower () ) class Foo : def __init__ ( self , t ): self . t = t With PEP484 \u00b6 In the above code samples the type was checked by instance_of(str) in the decorator, but you could also rather declare a type hint in the function/class signature and rely on a PEP484 checker library , that makes the decorator much more compact and focused on value validation only: from typing import Tuple from pytypes import typechecked from mini_lambda import InputVar , Len from valid8 import validate_arg # we need a mini_lambda variable named 't' t = InputVar ( 't' , tuple ) @typechecked @validate_arg ( 't' , # the first element is a float between 0 and 1 ( 0 <= t [ 0 ]) & ( t [ 0 ] <= 1 ), # the 2d element is a lowercase string of len 3 Len ( t [ 1 ]) == 3 , t [ 1 ] . islower () ) def my_function ( t : Tuple [ Real , str ]): pass However note that in this particular case, a tuple of wrong size will appear as a TypeError instead of a ValueError as we obtained previously. 4- Much easier: custom function \u00b6 The examples above demonstrate that even if you can validate complex types directly, at some point you will naturally want to create a dedicated custom validation function for each complex type to validate. Thus separating the validation means (the custom function) from the validation intent (naming, context, error message customization that you provide to validate or validator / validation ). That's exactly what valid8 is meant for! Let's start by creating a custom base validation function. The only constraint is to return True or nothing/ None in case of success, so we can implement a simple boolean checker . Note that we use instance_of instead of isinstance so that valid8 can distinguish between TypeError and ValueError : from valid8 import instance_of def is_valid_tuple ( t ): \"\"\" custom function - 'boolean tester' style (returning a bool) \"\"\" return instance_of ( t , tuple ) and len ( t ) == 2 \\ and instance_of ( t [ 0 ], Real ) and ( 0 <= t [ 0 ] <= 1 ) \\ and instance_of ( t [ 1 ], str ) and len ( t [ 1 ]) == 3 and t [ 1 ] . islower () or, better for our users (and even for our debug sessions), a failure raiser . In this case we do not need to use instance_of since we raise TypeError and ValueError explicitly: def check_valid_tuple ( t ): \"\"\" custom function - 'failure raiser' style (returning nothing) \"\"\" # item should be a tuple of length 2 if not isinstance ( t , tuple ): raise TypeError ( 'item should be a tuple' ) if len ( t ) != 2 : raise ValueError ( 'tuple length should be 2, found ' + str ( t )) # the first element is a float between 0 and 1 if not isinstance ( t [ 0 ], Real ): raise TypeError ( 'first elt should be a Real, found ' + str ( t [ 0 ])) if not ( 0 <= t [ 0 ] <= 1 ): raise ValueError ( 'first elt should be between 0 and 1,found ' + str ( t [ 0 ])) # the second element is a lowercase string of size 3 if not isinstance ( t [ 1 ], str ): raise TypeError ( 'second elt should be a string, found ' + str ( t [ 1 ])) if not ( len ( t [ 1 ]) == 3 and t [ 1 ] . islower ()): raise ValueError ( 'second elt should be a lowercase string of length 3,' 'found ' + str ( t [ 1 ])) We can then use either function with the valid8 tools. validate \u00b6 With is_valid_tuple (boolean tester): from valid8 import validate validate ( 't' , t , custom = is_valid_tuple ) or with check_valid_tuple (failure raiser): from valid8 import validate validate ( 't' , t , custom = check_valid_tuple ) It is exactly the same usage. validation / validator \u00b6 With is_valid_tuple (boolean tester) we need to return the flag in the context manager, so it is more natural to use the validator alias: from valid8 import validator with validator ( 't' , t ) as v : v . alid = is_valid_tuple ( t ) whereas with check_valid_tuple (failure raiser) we do not need to return anything, and the validation alias seems more natural: from valid8 import validation with validation ( 't' , t ): check_valid_tuple ( t ) function inputs \u00b6 With is_valid_tuple (boolean tester): from valid8 import validate_arg @validate_arg ( 't' , is_valid_tuple ) def my_function ( t ): pass or with check_valid_tuple (failure raiser): from valid8 import validate_arg @validate_arg ( 't' , check_valid_tuple ) def my_function ( t ): pass it is exactly the same usage classes fields \u00b6 With is_valid_tuple (boolean tester): from valid8 import validate_field @validate_field ( 't' , is_valid_tuple ) class Foo : def __init__ ( self , t ): self . t = t or with check_valid_tuple (failure raiser): from valid8 import validate_field @validate_field ( 't' , check_valid_tuple ) class Foo : def __init__ ( self , t ): self . t = t it is exactly the same usage more compact with pep484 \u00b6 Note that if you choose to use a PEP484 type checker such as pytypes , your custom validation function can be much more compact, as the tuple length and tuple elements types can be already described in the PEP484 type hint Tuple[Real, str] : from typing import Tuple from pytypes import typechecked @typechecked def is_valid_tuple_pep ( t : Tuple [ Real , str ]): \"\"\" custom validation function - note the PEP484 type hint above \"\"\" return len ( t ) == 2 and ( 0 <= t [ 0 ] <= 1 ) and len ( t [ 1 ]) == 3 and t [ 1 ] . islower () or from typing import Tuple from pytypes import typechecked @typechecked def check_valid_tuple_pep ( t : Tuple [ Real , str ]): \"\"\" custom validation function - note the PEP484 type hint above \"\"\" # the first element is a float between 0 and 1 if not ( 0 <= t [ 0 ] <= 1 ): raise ValueError ( 'first elt should be between 0 and 1,found ' + str ( t [ 0 ])) # the second element is a lowercase string of size 3 if not ( len ( t [ 1 ]) == 3 and t [ 1 ] . islower ()): raise ValueError ( 'second elt should be a lowercase string of length 3,' 'found ' + str ( t [ 1 ])) However note that in this particular case, a tuple of wrong size will appear as a TypeError instead of a ValueError as we obtained previously. 4- Variants \u00b6 TODO","title":"Example 3"},{"location":"examples/example3/#example-3-t-is-a-custom-tuple","text":"For example t is a tuple that contains a float between 0 and 1 and a lowercase trigram (three-letter lowercase string).","title":"Example 3 - t is a custom tuple"},{"location":"examples/example3/#1-example-values-to-validate","text":"# Valid t = ( 0.2 , 'foo' ) t = ( 1.0 , 'abc' ) t = ( 0 , 'foo' ) # we accept integers # Invalid t = 1.1 # wrong type (not a tuple) t = ( 0.2 , 'foo' , True ) # wrong size (size 3) t = ( '1.0' , 'foo' ) # wrong type ('1.0' is not a float) t = ( 1.1 , 'foo' ) # wrong value (1.1 is not between 0 and 1) t = ( 1.0 , False ) # wrong type (False is not a string) t = ( 0.5 , 'a' ) # wrong value ('a' is not of size 3) t = ( 0.5 , 'AAA' ) # wrong value ('AAA' is not lowercase)","title":"1- Example values to validate"},{"location":"examples/example3/#2-inline-validation","text":"","title":"2- Inline validation"},{"location":"examples/example3/#validate-built-ins","text":"validate can not perform everything at once without a custom validation function , but you can easily validate each element: from valid8 import validate validate ( 't' , t , instance_of = tuple , length = 2 ) validate ( 't[0]' , t [ 0 ], instance_of = Real , min_value = 0 , max_value = 1 ) validate ( 't[1]' , t [ 1 ], instance_of = str , length = 3 , custom = str . islower ) Note that we prefer to user custom=str.islower to check if a string is lowercase, rather than equals=s.lower() , as explained in previous example 2 .","title":"validate + built-ins"},{"location":"examples/example3/#with-validator-built-ins","text":"It is relatively straightforward to validate both t and its contents either with a pure \"boolean test\" approach (where we use instance_of instead of isinstance so that valid8 can distinguish between TypeError and ValueError ): from valid8 import validator , instance_of with validator ( 't' , t , instance_of = tuple ) as v : v . alid = len ( t ) == 2 \\ and instance_of ( t [ 0 ], Real ) and ( 0 <= t [ 0 ] <= 1 ) \\ and instance_of ( t [ 1 ], str ) and len ( t [ 1 ]) == 3 and t [ 1 ] . islower () or with a \"failure raising\" approach, less compact but with more explicit error messages: from valid8 import validation with validation ( 't' , t , instance_of = tuple ): # the tuple should be of length 2 if len ( t ) != 2 : raise ValueError ( 'tuple length should be 2, found ' + str ( t )) # the first element is a float between 0 and 1 if not isinstance ( t [ 0 ], Real ): raise TypeError ( 'first elt should be a Real, found ' + str ( t [ 0 ])) if not ( 0 <= t [ 0 ] <= 1 ): raise ValueError ( 'first elt should be between 0 and 1,found ' + str ( t [ 0 ])) # the second element is a lowercase string of size 3 if not isinstance ( t [ 1 ], str ): raise TypeError ( 'second elt should be a string, found ' + str ( t [ 1 ])) if not ( len ( t [ 1 ]) == 3 and t [ 1 ] . islower ()): raise ValueError ( 'second elt should be a lowercase string of length 3,' 'found ' + str ( t [ 1 ]))","title":"with validator + built-ins"},{"location":"examples/example3/#3-functionsclasses-validation","text":"","title":"3- Functions/classes validation"},{"location":"examples/example3/#principles","text":"Type can be checked with built-in instance_of Length can be checked with built-in has_length or mini-lambda Len(t) == 2 or custom functions There is no built-in function to check that s is lowercase yet, but as we saw above we can use the unbound class function str.islower or the mini-lambda s.islower() . We will not show all combinations here (please refer to example 1 for all kind of decorators), only a few examples:","title":"Principles"},{"location":"examples/example3/#function-input","text":"With pure built-in and stdlib. Note: we have to use on_each_ to map validation functions to each element of the tuple: from valid8 import validate_arg , instance_of , has_length , on_each_ , and_ , between @validate_arg ( 't' , instance_of ( tuple ), has_length ( 2 ), on_each_ ( # the first element is a float between 0 and 1 and_ ( instance_of ( Real ), between ( 0 , 1 )), # the 2d element is a lowercase string of len 3 and_ ( instance_of ( str ), has_length ( 3 ), str . islower ), )) def my_function ( t ): pass With pure mini-lambda. Note that mini-lambda allows you to directly access the inner elements inside the tuple with traditional indexing: from mini_lambda import InputVar , Len from valid8 import validate_arg , instance_of from valid8.validation_lib.mini_lambda import Instance_of # we need a mini_lambda variable named 't' t = InputVar ( 't' , tuple ) @validate_arg ( 't' , instance_of ( tuple ), Len ( t ) == 2 , # the first element is a float between 0 and 1 Instance_of ( t [ 0 ], Real ), ( 0 <= t [ 0 ]) & ( t [ 0 ] <= 1 ), # the 2d element is a lowercase string of len 3 Instance_of ( t [ 1 ], str ), Len ( t [ 1 ]) == 3 , t [ 1 ] . islower () ) def my_function ( t ): pass Also note that here as in all previous examples we want to use instance_of instead of isinstance in order to raise the correct TypeError . But instance_of is a standard function, it is not composable with mini-lambda expressions such as t[0] . Therefore we use the mini-lambda version of instance_of provided in this package, named Instance_of . This allows us to write type tests for sub-elements in the tuple, for example Instance_of(t[0], Real) .","title":"Function input"},{"location":"examples/example3/#class-fields","text":"In the examples below the class fields are defined as constructor arguments but this also works if they are defined as class descriptors/properties, and is compliant with autoclass and attrs with pure built-in and stdlib: from valid8 import validate_field , from valid8 import instance_of , has_length , on_each_ , and_ , between @validate_field ( 't' , instance_of ( tuple ), has_length ( 2 ), on_each_ ( # the first element is a float between 0 and 1 and_ ( instance_of ( Real ), between ( 0 , 1 )), # the 2d element is a lowercase string of len 3 and_ ( instance_of ( str ), has_length ( 3 ), str . islower ), )) class Foo : def __init__ ( self , t ): self . t = t or with pure mini-lambda from mini_lambda import InputVar , Len from valid8 import validate_field , instance_of from valid8.validation_lib.mini_lambda import Instance_of # we need a mini_lambda variable named 't' t = InputVar ( 't' , tuple ) @validate_field ( 't' , instance_of ( tuple ), Len ( t ) == 2 , # the first element is a float between 0 and 1 Instance_of ( t [ 0 ], Real ), ( 0 <= t [ 0 ]) & ( t [ 0 ] <= 1 ), # the 2d element is a lowercase string of len 3 Instance_of ( t [ 1 ], str ), Len ( t [ 1 ]) == 3 , t [ 1 ] . islower () ) class Foo : def __init__ ( self , t ): self . t = t","title":"Class fields"},{"location":"examples/example3/#with-pep484","text":"In the above code samples the type was checked by instance_of(str) in the decorator, but you could also rather declare a type hint in the function/class signature and rely on a PEP484 checker library , that makes the decorator much more compact and focused on value validation only: from typing import Tuple from pytypes import typechecked from mini_lambda import InputVar , Len from valid8 import validate_arg # we need a mini_lambda variable named 't' t = InputVar ( 't' , tuple ) @typechecked @validate_arg ( 't' , # the first element is a float between 0 and 1 ( 0 <= t [ 0 ]) & ( t [ 0 ] <= 1 ), # the 2d element is a lowercase string of len 3 Len ( t [ 1 ]) == 3 , t [ 1 ] . islower () ) def my_function ( t : Tuple [ Real , str ]): pass However note that in this particular case, a tuple of wrong size will appear as a TypeError instead of a ValueError as we obtained previously.","title":"With PEP484"},{"location":"examples/example3/#4-much-easier-custom-function","text":"The examples above demonstrate that even if you can validate complex types directly, at some point you will naturally want to create a dedicated custom validation function for each complex type to validate. Thus separating the validation means (the custom function) from the validation intent (naming, context, error message customization that you provide to validate or validator / validation ). That's exactly what valid8 is meant for! Let's start by creating a custom base validation function. The only constraint is to return True or nothing/ None in case of success, so we can implement a simple boolean checker . Note that we use instance_of instead of isinstance so that valid8 can distinguish between TypeError and ValueError : from valid8 import instance_of def is_valid_tuple ( t ): \"\"\" custom function - 'boolean tester' style (returning a bool) \"\"\" return instance_of ( t , tuple ) and len ( t ) == 2 \\ and instance_of ( t [ 0 ], Real ) and ( 0 <= t [ 0 ] <= 1 ) \\ and instance_of ( t [ 1 ], str ) and len ( t [ 1 ]) == 3 and t [ 1 ] . islower () or, better for our users (and even for our debug sessions), a failure raiser . In this case we do not need to use instance_of since we raise TypeError and ValueError explicitly: def check_valid_tuple ( t ): \"\"\" custom function - 'failure raiser' style (returning nothing) \"\"\" # item should be a tuple of length 2 if not isinstance ( t , tuple ): raise TypeError ( 'item should be a tuple' ) if len ( t ) != 2 : raise ValueError ( 'tuple length should be 2, found ' + str ( t )) # the first element is a float between 0 and 1 if not isinstance ( t [ 0 ], Real ): raise TypeError ( 'first elt should be a Real, found ' + str ( t [ 0 ])) if not ( 0 <= t [ 0 ] <= 1 ): raise ValueError ( 'first elt should be between 0 and 1,found ' + str ( t [ 0 ])) # the second element is a lowercase string of size 3 if not isinstance ( t [ 1 ], str ): raise TypeError ( 'second elt should be a string, found ' + str ( t [ 1 ])) if not ( len ( t [ 1 ]) == 3 and t [ 1 ] . islower ()): raise ValueError ( 'second elt should be a lowercase string of length 3,' 'found ' + str ( t [ 1 ])) We can then use either function with the valid8 tools.","title":"4- Much easier: custom function"},{"location":"examples/example3/#validate","text":"With is_valid_tuple (boolean tester): from valid8 import validate validate ( 't' , t , custom = is_valid_tuple ) or with check_valid_tuple (failure raiser): from valid8 import validate validate ( 't' , t , custom = check_valid_tuple ) It is exactly the same usage.","title":"validate"},{"location":"examples/example3/#validation-validator","text":"With is_valid_tuple (boolean tester) we need to return the flag in the context manager, so it is more natural to use the validator alias: from valid8 import validator with validator ( 't' , t ) as v : v . alid = is_valid_tuple ( t ) whereas with check_valid_tuple (failure raiser) we do not need to return anything, and the validation alias seems more natural: from valid8 import validation with validation ( 't' , t ): check_valid_tuple ( t )","title":"validation / validator"},{"location":"examples/example3/#function-inputs","text":"With is_valid_tuple (boolean tester): from valid8 import validate_arg @validate_arg ( 't' , is_valid_tuple ) def my_function ( t ): pass or with check_valid_tuple (failure raiser): from valid8 import validate_arg @validate_arg ( 't' , check_valid_tuple ) def my_function ( t ): pass it is exactly the same usage","title":"function inputs"},{"location":"examples/example3/#classes-fields","text":"With is_valid_tuple (boolean tester): from valid8 import validate_field @validate_field ( 't' , is_valid_tuple ) class Foo : def __init__ ( self , t ): self . t = t or with check_valid_tuple (failure raiser): from valid8 import validate_field @validate_field ( 't' , check_valid_tuple ) class Foo : def __init__ ( self , t ): self . t = t it is exactly the same usage","title":"classes fields"},{"location":"examples/example3/#more-compact-with-pep484","text":"Note that if you choose to use a PEP484 type checker such as pytypes , your custom validation function can be much more compact, as the tuple length and tuple elements types can be already described in the PEP484 type hint Tuple[Real, str] : from typing import Tuple from pytypes import typechecked @typechecked def is_valid_tuple_pep ( t : Tuple [ Real , str ]): \"\"\" custom validation function - note the PEP484 type hint above \"\"\" return len ( t ) == 2 and ( 0 <= t [ 0 ] <= 1 ) and len ( t [ 1 ]) == 3 and t [ 1 ] . islower () or from typing import Tuple from pytypes import typechecked @typechecked def check_valid_tuple_pep ( t : Tuple [ Real , str ]): \"\"\" custom validation function - note the PEP484 type hint above \"\"\" # the first element is a float between 0 and 1 if not ( 0 <= t [ 0 ] <= 1 ): raise ValueError ( 'first elt should be between 0 and 1,found ' + str ( t [ 0 ])) # the second element is a lowercase string of size 3 if not ( len ( t [ 1 ]) == 3 and t [ 1 ] . islower ()): raise ValueError ( 'second elt should be a lowercase string of length 3,' 'found ' + str ( t [ 1 ])) However note that in this particular case, a tuple of wrong size will appear as a TypeError instead of a ValueError as we obtained previously.","title":"more compact with pep484"},{"location":"examples/example3/#4-variants","text":"TODO","title":"4- Variants"},{"location":"examples/example4/","text":"4- l is a list of custom tuples \u00b6 (a) Inline - validate \u00b6 It is not possible to use validate to check all the tuples inside l at once, but it can be used in a for loop to validate each tuple. Note that we correctly set the name of each item that is validated, so that users get informative errors: from valid8 import validate # first validate the main type validate ( 'l' , l , instance_of = list ) # then validate (and use) the contents for i , v in enumerate ( l ): # each item is a tuple of size 2 validate ( 'l[{}]' . format ( i ), l [ i ], instance_of = tuple , length = 2 ) # the first element is a float between 0 and 1 validate ( 'l[{}][0]' . format ( i ), l [ i ][ 0 ], instance_of = Real , min_value = 0 , max_value = 1 ) # the second element is a lowercase string of size 3 validate ( 'l[{}][1]' . format ( i ), l [ i ][ 1 ], instance_of = str , length = 3 , equals = l [ i ][ 1 ] . lower ()) # here you can actually USE the current item (b) Inline - with validator \u00b6 You can perform the whole validation at once with validator as shown here: from valid8 import validator , instance_of with validator ( 'l' , l , instance_of = list ) as v : v . alid = all ( # each item is a tuple of size 2 instance_of ( item , tuple ) and len ( item ) == 2 # the first element is a float between 0 and 1 and instance_of ( item [ 0 ], Real ) and ( 0 <= item [ 0 ] <= 1 ) # the second element is a lowercase string of size 3 and instance_of ( item [ 1 ], str ) and len ( item [ 1 ]) == 3 and item [ 1 ] . islower () for item in l ) But it might not really make sense if you actually wish to use the tuples :). In that case it is much more readable and convenient to write a custom validation function check_valid_tuple first. Below is an example in \"failure raiser\" mode: the function does not return False in case of failure but rather raises more informative errors. def check_valid_tuple ( tup ): \"\"\" custom validation function - here in 'failure raiser' style (returning nothing) \"\"\" # each item is a tuple of size 2 if not isinstance ( tup , tuple ): raise TypeError ( 'item should be a tuple' ) if len ( tup ) != 2 : raise ValueError ( 'tuple length should be 2' ) # the first element is a float between 0 and 1 if not isinstance ( tup [ 0 ], Real ): raise TypeError ( 'first element should be a Real' ) if not ( 0 <= tup [ 0 ] <= 1 ): raise ValueError ( 'first element should be between 0 and 1' ) # the second element is a lowercase string of size 3 if not isinstance ( tup [ 1 ], str ): raise TypeError ( 'second element should be a string' ) if not ( len ( tup [ 1 ]) == 3 and tup [ 1 ] . islower ()): raise ValueError ( 'second element should be a lowercase string of length 3' ) We can then use it with a validation context manager: from valid8 import validate , validation # first validate the main type validate ( 'l' , l , instance_of = list ) # then validate (and use) the contents for i , v in enumerate ( l ): # each item is a valid tuple with validation ( 'l[{}]' . format ( i ), l [ i ]): check_valid_tuple ( l [ i ]) # here you can actually USE the current item Note that if you choose to use a PEP484 type checker such as pytypes , your custom validation function can be much more compact, as the tuple length and tuple elements types are described in the compact PEP484 type hint Tuple[Real, str] : from typing import Tuple from pytypes import typechecked @typechecked def check_valid_tuple ( tup : Tuple [ Real , str ]): \"\"\" custom validation function - note the PEP484 type hint above \"\"\" # the first element is a float between 0 and 1 if not ( 0 <= tup [ 0 ] <= 1 ): raise ValueError ( 'first element should be between 0 and 1' ) # the second element is a lowercase string of size 3 if not ( len ( tup [ 1 ]) == 3 and tup [ 1 ] . islower ()): raise ValueError ( 'second element should be a lowercase string of length 3' ) (c) Decorators - built-in lib \u00b6 For readability we only show one decorator here, see this previous example for other decorators and additional comments. There is no built-in function to check that l[i][1] is lowercase yet. The best we can do is from valid8 import validate_arg , instance_of , on_all_ , on_each_ , has_length , and_ , between @validate_arg ( 'l' , instance_of ( list ), on_all_ ( # each item is a tuple of size 2 instance_of ( tuple ), has_length ( 2 ), on_each_ ( # the first element is a float between 0 and 1 and_ ( instance_of ( Real ), between ( 0 , 1 )), # the 2d element is a string of len 3 BUT we cannot check lowercase and_ ( instance_of ( str ), has_length ( 3 )), ) )) def my_function ( l ): pass Although this proves that the provided built-in library can tackle complex cases, it also shows the limits of performing all validation directly in the decorator. In this case it is much more readable to create a custom function is_valid_tuple , and it allows you to actually check the lowercase part: def is_valid_tuple ( t ): \"\"\" Custom validation function. We could also provide a callable \"\"\" # (a) each item is a tuple of size 2 # --you can reuse an entire method from the built-in lib when it supports direct calling mode instance_of ( t , tuple ) # --otherwise you can reuse a failure class, there are many if len ( t ) != 2 : raise WrongLength ( t , ref_length = 2 ) # (b) the first element is a float between 0 and 1 if not isinstance ( t [ 0 ], Real ): raise HasWrongType ( t [ 0 ], Real ) if not ( 0 <= t [ 0 ] <= 1 ): raise NotInRange ( t [ 0 ], min_value = 0 , max_value = 1 ) # (c) the second element is a lowercase string of size 3 instance_of ( t [ 1 ], str ) if len ( t [ 1 ]) != 3 : raise WrongLength ( t [ 1 ], ref_length = 3 ) ValidationFailurelure types if not t [ 1 ] . islower (): raise NotLowerCase ( t [ 1 ]) class NotLowerCase ( ValidationFailurValidationFailurenisms than ValidationError ) \"\"\" help_msg = \"Value is not a lowercase string: {wrong_value}\" And finally you would use your custom function in the decorator: @validate_arg ( 'l' , instance_of ( list ), on_all_ ( is_valid_tuple )) def my_function ( l ): pass (d) Decorators - mini_lambda \u00b6 For readability we only show one decorator here, see this previous example for other decorators and additional comments. from valid8 import validate_arg , instance_of , on_all_ # just for fun: we create our custom mini_lambda variable named 't' from mini_lambda import InputVar , Len , Isinstance t = InputVar ( 't' , tuple ) @validate_arg ( 'l' , instance_of ( list ), on_all_ ( # each item is a tuple of size 2 instance_of ( tuple ), Len ( t ) == 2 , # the first element is a float between 0 and 1 Isinstance ( t [ 0 ], Real ), ( 0 <= t [ 0 ]) & ( t [ 0 ] <= 1 ), # the 2d element is a lowercase string of len 3 Isinstance ( t [ 1 ], str ), Len ( t [ 1 ]) == 3 , t [ 1 ] . islower () )) def my_function ( l ): pass","title":"Example 4"},{"location":"examples/example4/#4-l-is-a-list-of-custom-tuples","text":"","title":"4- l is a list of custom tuples"},{"location":"examples/example4/#a-inline-validate","text":"It is not possible to use validate to check all the tuples inside l at once, but it can be used in a for loop to validate each tuple. Note that we correctly set the name of each item that is validated, so that users get informative errors: from valid8 import validate # first validate the main type validate ( 'l' , l , instance_of = list ) # then validate (and use) the contents for i , v in enumerate ( l ): # each item is a tuple of size 2 validate ( 'l[{}]' . format ( i ), l [ i ], instance_of = tuple , length = 2 ) # the first element is a float between 0 and 1 validate ( 'l[{}][0]' . format ( i ), l [ i ][ 0 ], instance_of = Real , min_value = 0 , max_value = 1 ) # the second element is a lowercase string of size 3 validate ( 'l[{}][1]' . format ( i ), l [ i ][ 1 ], instance_of = str , length = 3 , equals = l [ i ][ 1 ] . lower ()) # here you can actually USE the current item","title":"(a) Inline - validate"},{"location":"examples/example4/#b-inline-with-validator","text":"You can perform the whole validation at once with validator as shown here: from valid8 import validator , instance_of with validator ( 'l' , l , instance_of = list ) as v : v . alid = all ( # each item is a tuple of size 2 instance_of ( item , tuple ) and len ( item ) == 2 # the first element is a float between 0 and 1 and instance_of ( item [ 0 ], Real ) and ( 0 <= item [ 0 ] <= 1 ) # the second element is a lowercase string of size 3 and instance_of ( item [ 1 ], str ) and len ( item [ 1 ]) == 3 and item [ 1 ] . islower () for item in l ) But it might not really make sense if you actually wish to use the tuples :). In that case it is much more readable and convenient to write a custom validation function check_valid_tuple first. Below is an example in \"failure raiser\" mode: the function does not return False in case of failure but rather raises more informative errors. def check_valid_tuple ( tup ): \"\"\" custom validation function - here in 'failure raiser' style (returning nothing) \"\"\" # each item is a tuple of size 2 if not isinstance ( tup , tuple ): raise TypeError ( 'item should be a tuple' ) if len ( tup ) != 2 : raise ValueError ( 'tuple length should be 2' ) # the first element is a float between 0 and 1 if not isinstance ( tup [ 0 ], Real ): raise TypeError ( 'first element should be a Real' ) if not ( 0 <= tup [ 0 ] <= 1 ): raise ValueError ( 'first element should be between 0 and 1' ) # the second element is a lowercase string of size 3 if not isinstance ( tup [ 1 ], str ): raise TypeError ( 'second element should be a string' ) if not ( len ( tup [ 1 ]) == 3 and tup [ 1 ] . islower ()): raise ValueError ( 'second element should be a lowercase string of length 3' ) We can then use it with a validation context manager: from valid8 import validate , validation # first validate the main type validate ( 'l' , l , instance_of = list ) # then validate (and use) the contents for i , v in enumerate ( l ): # each item is a valid tuple with validation ( 'l[{}]' . format ( i ), l [ i ]): check_valid_tuple ( l [ i ]) # here you can actually USE the current item Note that if you choose to use a PEP484 type checker such as pytypes , your custom validation function can be much more compact, as the tuple length and tuple elements types are described in the compact PEP484 type hint Tuple[Real, str] : from typing import Tuple from pytypes import typechecked @typechecked def check_valid_tuple ( tup : Tuple [ Real , str ]): \"\"\" custom validation function - note the PEP484 type hint above \"\"\" # the first element is a float between 0 and 1 if not ( 0 <= tup [ 0 ] <= 1 ): raise ValueError ( 'first element should be between 0 and 1' ) # the second element is a lowercase string of size 3 if not ( len ( tup [ 1 ]) == 3 and tup [ 1 ] . islower ()): raise ValueError ( 'second element should be a lowercase string of length 3' )","title":"(b) Inline - with validator"},{"location":"examples/example4/#c-decorators-built-in-lib","text":"For readability we only show one decorator here, see this previous example for other decorators and additional comments. There is no built-in function to check that l[i][1] is lowercase yet. The best we can do is from valid8 import validate_arg , instance_of , on_all_ , on_each_ , has_length , and_ , between @validate_arg ( 'l' , instance_of ( list ), on_all_ ( # each item is a tuple of size 2 instance_of ( tuple ), has_length ( 2 ), on_each_ ( # the first element is a float between 0 and 1 and_ ( instance_of ( Real ), between ( 0 , 1 )), # the 2d element is a string of len 3 BUT we cannot check lowercase and_ ( instance_of ( str ), has_length ( 3 )), ) )) def my_function ( l ): pass Although this proves that the provided built-in library can tackle complex cases, it also shows the limits of performing all validation directly in the decorator. In this case it is much more readable to create a custom function is_valid_tuple , and it allows you to actually check the lowercase part: def is_valid_tuple ( t ): \"\"\" Custom validation function. We could also provide a callable \"\"\" # (a) each item is a tuple of size 2 # --you can reuse an entire method from the built-in lib when it supports direct calling mode instance_of ( t , tuple ) # --otherwise you can reuse a failure class, there are many if len ( t ) != 2 : raise WrongLength ( t , ref_length = 2 ) # (b) the first element is a float between 0 and 1 if not isinstance ( t [ 0 ], Real ): raise HasWrongType ( t [ 0 ], Real ) if not ( 0 <= t [ 0 ] <= 1 ): raise NotInRange ( t [ 0 ], min_value = 0 , max_value = 1 ) # (c) the second element is a lowercase string of size 3 instance_of ( t [ 1 ], str ) if len ( t [ 1 ]) != 3 : raise WrongLength ( t [ 1 ], ref_length = 3 ) ValidationFailurelure types if not t [ 1 ] . islower (): raise NotLowerCase ( t [ 1 ]) class NotLowerCase ( ValidationFailurValidationFailurenisms than ValidationError ) \"\"\" help_msg = \"Value is not a lowercase string: {wrong_value}\" And finally you would use your custom function in the decorator: @validate_arg ( 'l' , instance_of ( list ), on_all_ ( is_valid_tuple )) def my_function ( l ): pass","title":"(c) Decorators - built-in lib"},{"location":"examples/example4/#d-decorators-mini_lambda","text":"For readability we only show one decorator here, see this previous example for other decorators and additional comments. from valid8 import validate_arg , instance_of , on_all_ # just for fun: we create our custom mini_lambda variable named 't' from mini_lambda import InputVar , Len , Isinstance t = InputVar ( 't' , tuple ) @validate_arg ( 'l' , instance_of ( list ), on_all_ ( # each item is a tuple of size 2 instance_of ( tuple ), Len ( t ) == 2 , # the first element is a float between 0 and 1 Isinstance ( t [ 0 ], Real ), ( 0 <= t [ 0 ]) & ( t [ 0 ] <= 1 ), # the 2d element is a lowercase string of len 3 Isinstance ( t [ 1 ], str ), Len ( t [ 1 ]) == 3 , t [ 1 ] . islower () )) def my_function ( l ): pass","title":"(d) Decorators - mini_lambda"},{"location":"examples/example5/","text":"Example 5 - df is a dataframe containing specific columns \u00b6 For example we want to check that 'foo' and 'bar' are present. 1- Example values to validate \u00b6 import pandas as pd # Valid df = pd . DataFrame ( data = { 'foo' : [ 1 , 2 ], 'bar' : [ None , \"hello\" ]}) df = pd . DataFrame ( data = { 'a' : [ 1 , 2 ], 'foo' : [ 'r' , 't' ], 'bar' : [ None , \"hello\" ]}) # Invalid df = pd . DataFrame ( data = { 'fo' : [ 1 , 2 ], 'bar' : [ None , \"hello\" ]}) # typo in name 2- Inline validation \u00b6 Principles: type can be checked with instance_of required columns can be checked by verifying that the set of actual columns is a superset of the required columns. Since this validation is simple, we show below how it can be done with valid8 alone. But to go further we rather recommend to combine it with another library validate + built-ins \u00b6 validate provides both type and superset validation built-in, but they do not apply to the same element so we have to call it twice: from valid8 import validate # type validation validate ( 'df' , df , instance_of = pd . DataFrame ) # columns validation required_cols = { 'foo' , 'bar' } validate ( 'df columns' , set ( df . columns ), superset_of = required_cols , help_msg = \"DataFrame should contain mandatory columns {c}. Found { var_value } \", c=required_cols) Note: you see in this example a reminder that the help message is formatted by valid8 using str.format() . You can use in this help message any custom keyword argument (such as c above) or any of the already-available variables. The best way to see what is available is to write a wrong help message with an unexistent variable name in the string template: validate ( 'df columns' , set ( df . columns ), superset_of = required_cols , help_msg = \"Just kidding {hoho}\" ) yields: ValidationError [ ValueError ] : Error while formatting help msg, keyword [ hoho ] was not found in the validation context. Help message to format was 'Just kidding {hoho}' . Context elements available: { 'display_prefix_for_exc_outcomes' : False, 'append_details' : True, 'validator' : _QuickValidator< validation_function = validate, none_policy = VALIDATE, exc_type = ValidationError>, 'var_value' : { 'fo' , 'bar' } , 'var_name' : 'df columns' , 'validation_outcome' : NotSuperset ( append_details = True,wrong_value ={ 'fo' , 'bar' } ,reference_set ={ 'foo' , 'bar' } ,missing ={ 'foo' } ,help_msg = x superset of { reference_set } does not hold for x ={ wrong_value } . Missing elements: { missing }) , 'help_msg' : 'Just kidding {hoho}' } with validator + built-ins \u00b6 It is relatively straightforward to validate both df and its columns either with a pure \"boolean test\" approach: from valid8 import validator required_cols = { 'foo' , 'bar' } with validator ( 'df' , df , instance_of = pd . DataFrame ) as v : missing = required_cols - set ( df . columns ) v . alid = len ( missing ) == 0 or with a \"failure raising\" approach, less compact (and not really more explicit error messages): from valid8 import validation required_cols = { 'foo' , 'bar' } with validation ( 'df' , df , instance_of = pd . DataFrame ): missing = required_cols - set ( df . columns ) if len ( missing ) > 0 : raise ValueError ( 'missing dataFrame columns: ' + str ( missing )) with validator + dedicated validation lib \u00b6 Of course in real world examples you will want to validate much more things. So you will typically rely on a dedicated library for dataframe validation, and you will use valid8 only for its primary target: having a strong control about exceptions readability and exceptions types (for i18n). For example: from my_pandas_validator import assert_df_minimum_size , assert_index_is_unique , \\ assert_index_is_sorted , assert_column_present_with_correct_type with validation ( 'df' , df , instance_of = pd . DataFrame , error_type = InvalidInputDataFrame ): assert_df_minimum_size ( df , min_nb_rows = 10 ) assert_index_is_unique ( df ) assert_index_is_sorted ( df ) assert_column_present_with_correct_type ( df , 'foo' , int ) 3- Functions/classes validation \u00b6 Function input \u00b6 with built-in validation functions it is not possible, we have to create our custom function: from valid8 import validate_arg , instance_of required_cols = { 'foo' , 'bar' } def has_required_cols ( df ): missing = required_cols - set ( df . columns ) if len ( missing ) > 0 : raise ValueError ( 'missing dataFrame columns: ' + str ( missing )) @validate_arg ( 'df' , instance_of ( pd . DataFrame ), has_required_cols ) def my_function ( df ): pass or with mini-lambda from valid8 import validate_arg , instance_of from mini_lambda import Set , Len from mini_lambda.pandas_ import df @validate_arg ( 'df' , instance_of ( pd . DataFrame ), Len ( required_cols - Set ( df . columns )) > 0 ) def my_function ( df ): pass Function output \u00b6 identical but with validate_out , see other examples. Function ios \u00b6 See other examples Class fields \u00b6 In the examples below the class fields are defined as constructor arguments but this also works if they are defined as class descriptors/properties, and is compliant with autoclass and attrs using custom function: from valid8 import validate_field , instance_of @validate_field ( 'df' , instance_of ( pd . DataFrame ), has_required_cols ) class Foo : def __init__ ( self , df ): self . df = df or with mini-lambda from valid8 import validate_field , instance_of from mini_lambda import Set , Len from mini_lambda.pandas_ import df @validate_field ( 'df' , instance_of ( pd . DataFrame ), Len ( required_cols - Set ( df . columns )) > 0 ) class Foo : def __init__ ( self , df ): self . df = df With PEP484 \u00b6 See other examples 4- Variants \u00b6","title":"Example 5"},{"location":"examples/example5/#example-5-df-is-a-dataframe-containing-specific-columns","text":"For example we want to check that 'foo' and 'bar' are present.","title":"Example 5 - df is a dataframe containing specific columns"},{"location":"examples/example5/#1-example-values-to-validate","text":"import pandas as pd # Valid df = pd . DataFrame ( data = { 'foo' : [ 1 , 2 ], 'bar' : [ None , \"hello\" ]}) df = pd . DataFrame ( data = { 'a' : [ 1 , 2 ], 'foo' : [ 'r' , 't' ], 'bar' : [ None , \"hello\" ]}) # Invalid df = pd . DataFrame ( data = { 'fo' : [ 1 , 2 ], 'bar' : [ None , \"hello\" ]}) # typo in name","title":"1- Example values to validate"},{"location":"examples/example5/#2-inline-validation","text":"Principles: type can be checked with instance_of required columns can be checked by verifying that the set of actual columns is a superset of the required columns. Since this validation is simple, we show below how it can be done with valid8 alone. But to go further we rather recommend to combine it with another library","title":"2- Inline validation"},{"location":"examples/example5/#validate-built-ins","text":"validate provides both type and superset validation built-in, but they do not apply to the same element so we have to call it twice: from valid8 import validate # type validation validate ( 'df' , df , instance_of = pd . DataFrame ) # columns validation required_cols = { 'foo' , 'bar' } validate ( 'df columns' , set ( df . columns ), superset_of = required_cols , help_msg = \"DataFrame should contain mandatory columns {c}. Found { var_value } \", c=required_cols) Note: you see in this example a reminder that the help message is formatted by valid8 using str.format() . You can use in this help message any custom keyword argument (such as c above) or any of the already-available variables. The best way to see what is available is to write a wrong help message with an unexistent variable name in the string template: validate ( 'df columns' , set ( df . columns ), superset_of = required_cols , help_msg = \"Just kidding {hoho}\" ) yields: ValidationError [ ValueError ] : Error while formatting help msg, keyword [ hoho ] was not found in the validation context. Help message to format was 'Just kidding {hoho}' . Context elements available: { 'display_prefix_for_exc_outcomes' : False, 'append_details' : True, 'validator' : _QuickValidator< validation_function = validate, none_policy = VALIDATE, exc_type = ValidationError>, 'var_value' : { 'fo' , 'bar' } , 'var_name' : 'df columns' , 'validation_outcome' : NotSuperset ( append_details = True,wrong_value ={ 'fo' , 'bar' } ,reference_set ={ 'foo' , 'bar' } ,missing ={ 'foo' } ,help_msg = x superset of { reference_set } does not hold for x ={ wrong_value } . Missing elements: { missing }) , 'help_msg' : 'Just kidding {hoho}' }","title":"validate + built-ins"},{"location":"examples/example5/#with-validator-built-ins","text":"It is relatively straightforward to validate both df and its columns either with a pure \"boolean test\" approach: from valid8 import validator required_cols = { 'foo' , 'bar' } with validator ( 'df' , df , instance_of = pd . DataFrame ) as v : missing = required_cols - set ( df . columns ) v . alid = len ( missing ) == 0 or with a \"failure raising\" approach, less compact (and not really more explicit error messages): from valid8 import validation required_cols = { 'foo' , 'bar' } with validation ( 'df' , df , instance_of = pd . DataFrame ): missing = required_cols - set ( df . columns ) if len ( missing ) > 0 : raise ValueError ( 'missing dataFrame columns: ' + str ( missing ))","title":"with validator + built-ins"},{"location":"examples/example5/#with-validator-dedicated-validation-lib","text":"Of course in real world examples you will want to validate much more things. So you will typically rely on a dedicated library for dataframe validation, and you will use valid8 only for its primary target: having a strong control about exceptions readability and exceptions types (for i18n). For example: from my_pandas_validator import assert_df_minimum_size , assert_index_is_unique , \\ assert_index_is_sorted , assert_column_present_with_correct_type with validation ( 'df' , df , instance_of = pd . DataFrame , error_type = InvalidInputDataFrame ): assert_df_minimum_size ( df , min_nb_rows = 10 ) assert_index_is_unique ( df ) assert_index_is_sorted ( df ) assert_column_present_with_correct_type ( df , 'foo' , int )","title":"with validator + dedicated validation lib"},{"location":"examples/example5/#3-functionsclasses-validation","text":"","title":"3- Functions/classes validation"},{"location":"examples/example5/#function-input","text":"with built-in validation functions it is not possible, we have to create our custom function: from valid8 import validate_arg , instance_of required_cols = { 'foo' , 'bar' } def has_required_cols ( df ): missing = required_cols - set ( df . columns ) if len ( missing ) > 0 : raise ValueError ( 'missing dataFrame columns: ' + str ( missing )) @validate_arg ( 'df' , instance_of ( pd . DataFrame ), has_required_cols ) def my_function ( df ): pass or with mini-lambda from valid8 import validate_arg , instance_of from mini_lambda import Set , Len from mini_lambda.pandas_ import df @validate_arg ( 'df' , instance_of ( pd . DataFrame ), Len ( required_cols - Set ( df . columns )) > 0 ) def my_function ( df ): pass","title":"Function input"},{"location":"examples/example5/#function-output","text":"identical but with validate_out , see other examples.","title":"Function output"},{"location":"examples/example5/#function-ios","text":"See other examples","title":"Function ios"},{"location":"examples/example5/#class-fields","text":"In the examples below the class fields are defined as constructor arguments but this also works if they are defined as class descriptors/properties, and is compliant with autoclass and attrs using custom function: from valid8 import validate_field , instance_of @validate_field ( 'df' , instance_of ( pd . DataFrame ), has_required_cols ) class Foo : def __init__ ( self , df ): self . df = df or with mini-lambda from valid8 import validate_field , instance_of from mini_lambda import Set , Len from mini_lambda.pandas_ import df @validate_field ( 'df' , instance_of ( pd . DataFrame ), Len ( required_cols - Set ( df . columns )) > 0 ) class Foo : def __init__ ( self , df ): self . df = df","title":"Class fields"},{"location":"examples/example5/#with-pep484","text":"See other examples","title":"With PEP484"},{"location":"examples/example5/#4-variants","text":"","title":"4- Variants"},{"location":"examples/overview/","text":"Usage examples / recipes \u00b6 In these pages we try to provide real-world examples so that you may find an answer for most common validation tasks, according to your coding style (several are proposed). Feel free to propose some examples through a git issue or pull request ! Common imports \u00b6 In all examples, we use numbers.Integral rather than int so as to support both python primitive int and other compliant types such as numpy int . The same goes for numbers.Real and valid8.Boolean (yes, unfortunately such an equivalent boolean type is not provided by the stdlib). from numbers import Integral , Real from valid8 import Boolean Examples list \u00b6 Example 1 : x is a positive integer. This is the most simple example. Example 2 : s is a lowercase non-empty string. In this example we start to see the limits of built-in functions and parameters, but are still able to find workarounds without writing custom functions. Example 3 : t is a custom tuple. In this example it becomes clearly easier/more readable to write a custom function and use it in the validation tools Example 4 : l is a list of custom tuples. This is to demonstrate iterative validation on container objects. Example 5 : df is a dataframe containing specific columns Example 6 : x and y should be such that either x is A or B and y is None , or x is C and y is a positive integer. This example demonstrates how to use the validation tools for combination of variables ( TODO ) Note: we deliberately do not use any help_msg or error_type customization in any of the examples to focus on the validation core. See here for details on how to customize these examples.","title":"Overview"},{"location":"examples/overview/#usage-examples-recipes","text":"In these pages we try to provide real-world examples so that you may find an answer for most common validation tasks, according to your coding style (several are proposed). Feel free to propose some examples through a git issue or pull request !","title":"Usage examples / recipes"},{"location":"examples/overview/#common-imports","text":"In all examples, we use numbers.Integral rather than int so as to support both python primitive int and other compliant types such as numpy int . The same goes for numbers.Real and valid8.Boolean (yes, unfortunately such an equivalent boolean type is not provided by the stdlib). from numbers import Integral , Real from valid8 import Boolean","title":"Common imports"},{"location":"examples/overview/#examples-list","text":"Example 1 : x is a positive integer. This is the most simple example. Example 2 : s is a lowercase non-empty string. In this example we start to see the limits of built-in functions and parameters, but are still able to find workarounds without writing custom functions. Example 3 : t is a custom tuple. In this example it becomes clearly easier/more readable to write a custom function and use it in the validation tools Example 4 : l is a list of custom tuples. This is to demonstrate iterative validation on container objects. Example 5 : df is a dataframe containing specific columns Example 6 : x and y should be such that either x is A or B and y is None , or x is C and y is a positive integer. This example demonstrates how to use the validation tools for combination of variables ( TODO ) Note: we deliberately do not use any help_msg or error_type customization in any of the examples to focus on the validation core. See here for details on how to customize these examples.","title":"Examples list"},{"location":"validation_funcs/a_basics/","text":"Validation functions - basics \u00b6 Below you will learn what is required to integrate any user-defined or 3d party function, and how to improve existing functions. 1. Accepted validation functions \u00b6 There seem to be two main styles out there when it comes to writing validation functions: boolean testers such as isfinite : they return True in case of success and False in case of failure, and therefore do not provide any details about the failure when they fail. Sometimes they continue to raise exceptions on edge cases ( isfinite(None) , isfinite(1+1j) ). failure raisers such as check_uniform_sampling or assert_series_equal : they do not return anything in case of success, but raise exceptions with details in case of failure. In order to be as open as possible, the definition of accepted functions in valid8 is very large. Is considered a 'valid' validation function any callable that: takes a single argument as input returns True or None in case of success That's the two only requirements. That means that base validation functions may fail the way they like : returning False or something else, raising Exception s. Name used in error messages \u00b6 In validation error messages, the name of the function that will be displayed is obtained from the validation callable v_callable with the following formula: name = v_callable . __name__ if hasattr ( v_callable , '__name__' ) else str ( v_callable ) 2. Creating failure raisers for better user experience \u00b6 As explained above, nothing else than returning True or None in case of success is required by valid8 . However, you might wish to use failure raisers rather than boolean testers because in case of failure they can provide many useful details in the raised exception . This is how you can do it: a - Writing your own \u00b6 You may wish to create a custom validation function that directly raises an instance or subclass of the valid8.ValidationFailure class: it provides a simple way to define help messages as class members, with a templating mechanism. All functions in the built-in library are done that way. For example this is the code for the non_empty validation function: from valid8 import ValidationFailure class Empty ( ValidationFailure , ValueError ): \"\"\" Custom ValidationFailure raised by non_empty \"\"\" help_msg = 'len(x) > 0 does not hold for x={wrong_value}' def non_empty ( x ): \"\"\" 'non empty' validation function. Raises a `Empty` error in case of failure. \"\"\" if len ( x ) > 0 : return True else : raise Empty ( wrong_value = x ) You can find some inspiration here . Sometimes it might be easier for a quick test, to add the \"failure raiser\" facet to one of your existing functions. For this you can use the @as_failure_raiser decorator: from valid8 import as_failure_raiser @as_failure_raiser ( help_msg = 'x should be strictly positive' ) def is_strictly_positive ( x ): return x > 0 b - Enriching an existing function \u00b6 An alternative is to transform existing functions into failure raisers by adding help messages or custom ValidationFailure subtypes. Indeed, often the validation functions that you want to reuse are designed to be efficient, therefore their outcome in case of failure might be cryptic for the end user. on the fly in the entry point \u00b6 Most valid8 entry points and composition operators support the simple validation function definition syntax explained here . Thanks to this syntax, you can transform existing functions into failure raisers on the fly, when you use them. For example you can add a custom message to isfinite : >>> from valid8 import validate >>> from math import inf , isfinite >>> x = inf >>> validate ( 'x' , x , custom = { 'x is not finite' : isfinite }) valid8 . entry_points . ValidationError [ ValueError ]: \\ Error validating [ x = inf ] . InvalidValue : x is not finite . \\ Function [ isfinite ] returned [ False ] for value inf . You can also specify a custom failure class that should be raised: >>> from valid8 import validate , ValidationFailure >>> from math import inf , isfinite >>> class NotFinite ( ValidationFailure ): ... help_msg = \"x is not finite\" ... >>> x = inf >>> validate ( 'x' , x , custom = { NotFinite : isfinite }) valid8 . entry_points . ValidationError [ ValueError ]: \\ Error validating [ x = inf ] . NotFinite : x is not finite . \\ Function [ isfinite ] returned [ False ] for value inf . permanently for reuse \u00b6 If you wish to reuse a validation function in many places, it might be simpler to convert it to a failure raiser once. You can transform an existing validation function in a failure raiser with failure_raiser() : from valid8 import failure_raiser from math import isfinite # custom message only new_func = failure_raiser ( isfinite , help_msg = 'x is not finite' ) # custom failure type new_func = failure_raiser ( isfinite , failure_type = NotFinite ) You can do the same with the @as_failure_raiser decorator already presented above. c - Docstring \u00b6 failure_raiser \u00b6 def failure_raiser ( validation_callable , # type: ValidationCallableOrLambda help_msg = None , # type: str failure_type = None , # type: Type[ValidationFailed] ** kw_context_args ): # type: (...) -> ValidationCallable Wraps the provided validation function so that in case of failure it raises the given failure_type or a WrappingFailure ValidationFailed help message. mini-lambda functions are automatically transformed to functions. See help(failure_raiser) @as_failure_raiser \u00b6 def as_failure_raiser ( failure_type = None , # type: Type[ValidationFailure] help_msg = None , # type: str ** kw_context_args ): A decorator to define a failure raiser. Same functionality then failure_raiser : from valid8 import as_failure_raiser @as_failure_raiser ( help_msg = \"x should be smaller than 4\" ) def is_small_with_details ( x ): return x < 4 >>> is_small_with_details(2) >>> is_small_with_details(11) Traceback (most recent call last): ... valid8.base.InvalidValue: x should be smaller than 4. Function [is_small_with_details] returned [False] for value 11.","title":"Basics"},{"location":"validation_funcs/a_basics/#validation-functions-basics","text":"Below you will learn what is required to integrate any user-defined or 3d party function, and how to improve existing functions.","title":"Validation functions - basics"},{"location":"validation_funcs/a_basics/#1-accepted-validation-functions","text":"There seem to be two main styles out there when it comes to writing validation functions: boolean testers such as isfinite : they return True in case of success and False in case of failure, and therefore do not provide any details about the failure when they fail. Sometimes they continue to raise exceptions on edge cases ( isfinite(None) , isfinite(1+1j) ). failure raisers such as check_uniform_sampling or assert_series_equal : they do not return anything in case of success, but raise exceptions with details in case of failure. In order to be as open as possible, the definition of accepted functions in valid8 is very large. Is considered a 'valid' validation function any callable that: takes a single argument as input returns True or None in case of success That's the two only requirements. That means that base validation functions may fail the way they like : returning False or something else, raising Exception s.","title":"1. Accepted validation functions"},{"location":"validation_funcs/a_basics/#name-used-in-error-messages","text":"In validation error messages, the name of the function that will be displayed is obtained from the validation callable v_callable with the following formula: name = v_callable . __name__ if hasattr ( v_callable , '__name__' ) else str ( v_callable )","title":"Name used in error messages"},{"location":"validation_funcs/a_basics/#2-creating-failure-raisers-for-better-user-experience","text":"As explained above, nothing else than returning True or None in case of success is required by valid8 . However, you might wish to use failure raisers rather than boolean testers because in case of failure they can provide many useful details in the raised exception . This is how you can do it:","title":"2. Creating failure raisers for better user experience"},{"location":"validation_funcs/a_basics/#a-writing-your-own","text":"You may wish to create a custom validation function that directly raises an instance or subclass of the valid8.ValidationFailure class: it provides a simple way to define help messages as class members, with a templating mechanism. All functions in the built-in library are done that way. For example this is the code for the non_empty validation function: from valid8 import ValidationFailure class Empty ( ValidationFailure , ValueError ): \"\"\" Custom ValidationFailure raised by non_empty \"\"\" help_msg = 'len(x) > 0 does not hold for x={wrong_value}' def non_empty ( x ): \"\"\" 'non empty' validation function. Raises a `Empty` error in case of failure. \"\"\" if len ( x ) > 0 : return True else : raise Empty ( wrong_value = x ) You can find some inspiration here . Sometimes it might be easier for a quick test, to add the \"failure raiser\" facet to one of your existing functions. For this you can use the @as_failure_raiser decorator: from valid8 import as_failure_raiser @as_failure_raiser ( help_msg = 'x should be strictly positive' ) def is_strictly_positive ( x ): return x > 0","title":"a - Writing your own"},{"location":"validation_funcs/a_basics/#b-enriching-an-existing-function","text":"An alternative is to transform existing functions into failure raisers by adding help messages or custom ValidationFailure subtypes. Indeed, often the validation functions that you want to reuse are designed to be efficient, therefore their outcome in case of failure might be cryptic for the end user.","title":"b - Enriching an existing function"},{"location":"validation_funcs/a_basics/#on-the-fly-in-the-entry-point","text":"Most valid8 entry points and composition operators support the simple validation function definition syntax explained here . Thanks to this syntax, you can transform existing functions into failure raisers on the fly, when you use them. For example you can add a custom message to isfinite : >>> from valid8 import validate >>> from math import inf , isfinite >>> x = inf >>> validate ( 'x' , x , custom = { 'x is not finite' : isfinite }) valid8 . entry_points . ValidationError [ ValueError ]: \\ Error validating [ x = inf ] . InvalidValue : x is not finite . \\ Function [ isfinite ] returned [ False ] for value inf . You can also specify a custom failure class that should be raised: >>> from valid8 import validate , ValidationFailure >>> from math import inf , isfinite >>> class NotFinite ( ValidationFailure ): ... help_msg = \"x is not finite\" ... >>> x = inf >>> validate ( 'x' , x , custom = { NotFinite : isfinite }) valid8 . entry_points . ValidationError [ ValueError ]: \\ Error validating [ x = inf ] . NotFinite : x is not finite . \\ Function [ isfinite ] returned [ False ] for value inf .","title":"on the fly in the entry point"},{"location":"validation_funcs/a_basics/#permanently-for-reuse","text":"If you wish to reuse a validation function in many places, it might be simpler to convert it to a failure raiser once. You can transform an existing validation function in a failure raiser with failure_raiser() : from valid8 import failure_raiser from math import isfinite # custom message only new_func = failure_raiser ( isfinite , help_msg = 'x is not finite' ) # custom failure type new_func = failure_raiser ( isfinite , failure_type = NotFinite ) You can do the same with the @as_failure_raiser decorator already presented above.","title":"permanently for reuse"},{"location":"validation_funcs/a_basics/#c-docstring","text":"","title":"c - Docstring"},{"location":"validation_funcs/a_basics/#failure_raiser","text":"def failure_raiser ( validation_callable , # type: ValidationCallableOrLambda help_msg = None , # type: str failure_type = None , # type: Type[ValidationFailed] ** kw_context_args ): # type: (...) -> ValidationCallable Wraps the provided validation function so that in case of failure it raises the given failure_type or a WrappingFailure ValidationFailed help message. mini-lambda functions are automatically transformed to functions. See help(failure_raiser)","title":"failure_raiser"},{"location":"validation_funcs/a_basics/#as_failure_raiser","text":"def as_failure_raiser ( failure_type = None , # type: Type[ValidationFailure] help_msg = None , # type: str ** kw_context_args ): A decorator to define a failure raiser. Same functionality then failure_raiser : from valid8 import as_failure_raiser @as_failure_raiser ( help_msg = \"x should be smaller than 4\" ) def is_small_with_details ( x ): return x < 4 >>> is_small_with_details(2) >>> is_small_with_details(11) Traceback (most recent call last): ... valid8.base.InvalidValue: x should be smaller than 4. Function [is_small_with_details] returned [False] for value 11.","title":"@as_failure_raiser"},{"location":"validation_funcs/b_base_validation_lib/","text":"Base validation functions library \u00b6 Several base validation functions are bundled in the package so as to be reused inside any of the validation entry points provided by valid8 . A quick way to get the up-to-date list of validation functions provided in this package is to execute the following help commands from within a terminal import valid8.validation_lib # get the list of submodules containing base validation functions help ( valid8 . validation_lib ) # get the list of base validation functions for each submodule help ( valid8 . validation_lib . numbers ) # help on a specific function help ( valid8 . validation_lib . numbers . is_multiple_of ) If you do not find the function you're looking for in this list, don't hesitate to propose new ones ! Submit a pull request or an issue here . In parallel, if your function is very specific but writes quite well in plain old python syntax, mini_lambda may provide a good alternative. Types \u00b6 instance_of(ref_type) \u00b6 'instance of' validation function generator. Returns a validation function to check that is_instance(x, ref_type) . If ref_type is a set of types, any match with one of the included types will do. from valid8 import assert_valid from valid8.validation_lib import instance_of assert_valid ( 'Foo' , 'r' , instance_of ( str )) Note that this function can also be used directly in inline codes, by using its 2-args version: instance_of(x, str) . subclass_of(ref_type) \u00b6 'subclass of' validation function generator. Returns a validation function to check that is_subclass(x, ref_type) . from valid8 import assert_valid from valid8.validation_lib import subclass_of assert_valid ( 'Foo' , bool , subclass_of ( int )) Note that this function can also be used directly in inline codes, by using its 2-args version: subclass_of(c, int) . Comparables \u00b6 gt(min_value, strict:bool=False) \u00b6 'Greater than' validation function generator. Returns a validation function to check that x >= min_value (strict=False, default) or x > min_value (strict=True). gts(min_value) \u00b6 Alias for 'greater than' validation function generator in strict mode. lt(max_value, strict:bool=False) \u00b6 'Lesser than' validation function generator. Returns a validation function to check that x <= max_value (strict=False, default) or x < max_value (strict=True). lts(max_value) \u00b6 Alias for 'lesser than' validation function generator in strict mode. between(min_value, max_value, open_left:bool=False, open_right:bool=False) \u00b6 'Is between' validation function generator. Returns a validation function to check that min_val <= x <= max_val (default). open_right and open_left flags allow to transform each side into strict mode. For example setting open_left=True will enforce min_val < x <= max_val . Numbers \u00b6 is_even \u00b6 Validates that x is even ( x % 2 == 0 ). is_odd \u00b6 Validates that x is odd ( x % 2 != 0 ). is_multiple_of(ref) \u00b6 'Is multiple of' validation function generator. Returns a validation function to check that x is a multiple of the reference ( x % ref == 0 ). Collections \u00b6 empty \u00b6 'empty' validation function. Raises a NotEmpty error in case of failure. non_empty \u00b6 'non empty' validation function. Raises a Empty error in case of failure. has_length(ref_length) \u00b6 'length equals' validation function generator. Returns a validation_function to check that len(x) == ref_length minlen(min_length) \u00b6 'Minimum length' validation function generator. Returns a validation function to check that len(x) >= min_length . maxlen(max_length) \u00b6 'Maximum length' validation function generator. Returns a validation function to check that len(x) <= max_length . length_between(min_len, max_len) \u00b6 'Is length between' validation_function generator. Returns a validation_function to check that min_len <= len(x) <= max_len (default) . is_in(allowed_values) \u00b6 'Values in' validation function generator. Returns a validation function to check that x is in the provided set allowed_values . is_subset(reference_set) \u00b6 'Is subset' validation function generator. Returns a validation function to check that x is a subset of reference_set . That is, len(x - reference_set) == 0 . contains(ref_value) \u00b6 'Contains' validation_function generator. Returns a validation_function to check that ref_value in x is_superset(reference_set) \u00b6 'Is superset' validation function generator. Returns a validation function to check that x is a superset of reference_set . That is, len(reference_set - x) == 0 . on_all_(*validation functions_for_all_elts) \u00b6 Generates a validation function for collection inputs where each element of the input will be validated against the validation functions provided. For convenience, a list of validation functions can be provided and will be replaced with an and_ . Note that if you want to apply DIFFERENT validation functions for each element in the input collection, you should rather use on_each_ . on_each_(*validation functions_collection) \u00b6 Generates a validation function for collection inputs where each element of the input will be validated against the corresponding validation function(s) in the validation functions_collection. Validators inside the tuple can be provided as a list for convenience, this will be replaced with an and_ operator if the list has more than one element. Note that if you want to apply the SAME validation functions to all elements in the input, you should rather use on_all_ .","title":"Built-in validation functions"},{"location":"validation_funcs/b_base_validation_lib/#base-validation-functions-library","text":"Several base validation functions are bundled in the package so as to be reused inside any of the validation entry points provided by valid8 . A quick way to get the up-to-date list of validation functions provided in this package is to execute the following help commands from within a terminal import valid8.validation_lib # get the list of submodules containing base validation functions help ( valid8 . validation_lib ) # get the list of base validation functions for each submodule help ( valid8 . validation_lib . numbers ) # help on a specific function help ( valid8 . validation_lib . numbers . is_multiple_of ) If you do not find the function you're looking for in this list, don't hesitate to propose new ones ! Submit a pull request or an issue here . In parallel, if your function is very specific but writes quite well in plain old python syntax, mini_lambda may provide a good alternative.","title":"Base validation functions library"},{"location":"validation_funcs/b_base_validation_lib/#types","text":"","title":"Types"},{"location":"validation_funcs/b_base_validation_lib/#instance_ofref_type","text":"'instance of' validation function generator. Returns a validation function to check that is_instance(x, ref_type) . If ref_type is a set of types, any match with one of the included types will do. from valid8 import assert_valid from valid8.validation_lib import instance_of assert_valid ( 'Foo' , 'r' , instance_of ( str )) Note that this function can also be used directly in inline codes, by using its 2-args version: instance_of(x, str) .","title":"instance_of(ref_type)"},{"location":"validation_funcs/b_base_validation_lib/#subclass_ofref_type","text":"'subclass of' validation function generator. Returns a validation function to check that is_subclass(x, ref_type) . from valid8 import assert_valid from valid8.validation_lib import subclass_of assert_valid ( 'Foo' , bool , subclass_of ( int )) Note that this function can also be used directly in inline codes, by using its 2-args version: subclass_of(c, int) .","title":"subclass_of(ref_type)"},{"location":"validation_funcs/b_base_validation_lib/#comparables","text":"","title":"Comparables"},{"location":"validation_funcs/b_base_validation_lib/#gtmin_value-strictboolfalse","text":"'Greater than' validation function generator. Returns a validation function to check that x >= min_value (strict=False, default) or x > min_value (strict=True).","title":"gt(min_value, strict:bool=False)"},{"location":"validation_funcs/b_base_validation_lib/#gtsmin_value","text":"Alias for 'greater than' validation function generator in strict mode.","title":"gts(min_value)"},{"location":"validation_funcs/b_base_validation_lib/#ltmax_value-strictboolfalse","text":"'Lesser than' validation function generator. Returns a validation function to check that x <= max_value (strict=False, default) or x < max_value (strict=True).","title":"lt(max_value, strict:bool=False)"},{"location":"validation_funcs/b_base_validation_lib/#ltsmax_value","text":"Alias for 'lesser than' validation function generator in strict mode.","title":"lts(max_value)"},{"location":"validation_funcs/b_base_validation_lib/#betweenmin_value-max_value-open_leftboolfalse-open_rightboolfalse","text":"'Is between' validation function generator. Returns a validation function to check that min_val <= x <= max_val (default). open_right and open_left flags allow to transform each side into strict mode. For example setting open_left=True will enforce min_val < x <= max_val .","title":"between(min_value, max_value, open_left:bool=False, open_right:bool=False)"},{"location":"validation_funcs/b_base_validation_lib/#numbers","text":"","title":"Numbers"},{"location":"validation_funcs/b_base_validation_lib/#is_even","text":"Validates that x is even ( x % 2 == 0 ).","title":"is_even"},{"location":"validation_funcs/b_base_validation_lib/#is_odd","text":"Validates that x is odd ( x % 2 != 0 ).","title":"is_odd"},{"location":"validation_funcs/b_base_validation_lib/#is_multiple_ofref","text":"'Is multiple of' validation function generator. Returns a validation function to check that x is a multiple of the reference ( x % ref == 0 ).","title":"is_multiple_of(ref)"},{"location":"validation_funcs/b_base_validation_lib/#collections","text":"","title":"Collections"},{"location":"validation_funcs/b_base_validation_lib/#empty","text":"'empty' validation function. Raises a NotEmpty error in case of failure.","title":"empty"},{"location":"validation_funcs/b_base_validation_lib/#non_empty","text":"'non empty' validation function. Raises a Empty error in case of failure.","title":"non_empty"},{"location":"validation_funcs/b_base_validation_lib/#has_lengthref_length","text":"'length equals' validation function generator. Returns a validation_function to check that len(x) == ref_length","title":"has_length(ref_length)"},{"location":"validation_funcs/b_base_validation_lib/#minlenmin_length","text":"'Minimum length' validation function generator. Returns a validation function to check that len(x) >= min_length .","title":"minlen(min_length)"},{"location":"validation_funcs/b_base_validation_lib/#maxlenmax_length","text":"'Maximum length' validation function generator. Returns a validation function to check that len(x) <= max_length .","title":"maxlen(max_length)"},{"location":"validation_funcs/b_base_validation_lib/#length_betweenmin_len-max_len","text":"'Is length between' validation_function generator. Returns a validation_function to check that min_len <= len(x) <= max_len (default) .","title":"length_between(min_len, max_len)"},{"location":"validation_funcs/b_base_validation_lib/#is_inallowed_values","text":"'Values in' validation function generator. Returns a validation function to check that x is in the provided set allowed_values .","title":"is_in(allowed_values)"},{"location":"validation_funcs/b_base_validation_lib/#is_subsetreference_set","text":"'Is subset' validation function generator. Returns a validation function to check that x is a subset of reference_set . That is, len(x - reference_set) == 0 .","title":"is_subset(reference_set)"},{"location":"validation_funcs/b_base_validation_lib/#containsref_value","text":"'Contains' validation_function generator. Returns a validation_function to check that ref_value in x","title":"contains(ref_value)"},{"location":"validation_funcs/b_base_validation_lib/#is_supersetreference_set","text":"'Is superset' validation function generator. Returns a validation function to check that x is a superset of reference_set . That is, len(reference_set - x) == 0 .","title":"is_superset(reference_set)"},{"location":"validation_funcs/b_base_validation_lib/#on_all_validation-functions_for_all_elts","text":"Generates a validation function for collection inputs where each element of the input will be validated against the validation functions provided. For convenience, a list of validation functions can be provided and will be replaced with an and_ . Note that if you want to apply DIFFERENT validation functions for each element in the input collection, you should rather use on_each_ .","title":"on_all_(*validation functions_for_all_elts)"},{"location":"validation_funcs/b_base_validation_lib/#on_each_validation-functions_collection","text":"Generates a validation function for collection inputs where each element of the input will be validated against the corresponding validation function(s) in the validation functions_collection. Validators inside the tuple can be provided as a list for convenience, this will be replaced with an and_ operator if the list has more than one element. Note that if you want to apply the SAME validation functions to all elements in the input, you should rather use on_all_ .","title":"on_each_(*validation functions_collection)"},{"location":"validation_funcs/c_simple_syntax/","text":"Simple syntax for validation functions \u00b6 We have seen in previous section that validation functions should either return True or None in case of success, that's the only requirement from valid8 standpoint. We also have seen that you can improve them by explicitly transforming them into custom failure raisers . In the next section we will see how to compose several validation functions together. In this section we will show how to both compose several validation functions and augment them into failure raisers, using in a simple and compact syntax . All valid8 entry points except the context manager support this simple syntax. using the simple syntax in the with validation context manager To use this syntax with the with validation context manager, you can use an explicit and_() in the code block. and_ accepts the syntax. 1. One validation function \u00b6 You can define a validation function by providing either a <callable> , or a tuple : (<callable>, <error_msg>) , (<callable>, <failure_type>) or (<callable>, <error_msg>, <failure_type>) . <validation_func> should be a callable with one argument: f(val) . It should return True or None in case of success. If it is a mini-lambda expression it will automatically be transformed into a function using mini_lambda.as_function . See ValidationCallable type hint. <err_msg> should be a string, possibly using the template mechanism <failure_type> should be a subclass of ValidationFailure For example we can add a custom message to isfinite : from valid8 import validate from math import inf , isfinite x = inf validate ( 'x' , x , custom = ( isfinite , 'x is not finite' )) yields valid8.entry_points.ValidationError [ ValueError ] : \\ Error validating [ x = inf ] . InvalidValue: x is not finite. \\ Function [ isfinite ] returned [ False ] for value inf. or if you prefer defining a reusable failure class: from valid8 import validate , ValidationFailure from math import inf , isfinite class NotFinite ( ValidationFailure ): help_msg = \"x is not finite\" x = inf validate ( 'x' , x , custom = ( isfinite , NotFinite )) yields ValidationError [ ValueError ] : Error validating [ x = inf ] . NotFinite: x is not finite. Function [ isfinite ] returned [ False ] for value inf. This syntax also works in @validate_arg , @validate_out , @validate_ios , @validate_field , and in the composition operators such as and_() . 2. Several validation functions \u00b6 You can easily declare that several validators should be combined with an implicit and_ by providing a non-tuple iterable containing validation function definitions , in other words a list containing <callable> , tuples (<callable>, <error_msg>) , (<callable>, <failure_type>) or (<callable>, <error_msg>, <failure_type>) . For example: from valid8 import validate , ValidationFailure from math import isfinite from mini_lambda import i class NotFinite ( ValidationFailure ): help_msg = \"x is not finite\" x = 2 validate ( 'x' , x , custom = [( i ** 2 < 50 , 'x should be fairly small' ), i % 3 == 0 , ( isfinite , NotFinite )]) yields ValidationError [ ValueError ] : Error validating [ x = 2 ] . At least one validation function failed for value 2 . Successes: [ 'i ** 2 < 50' , 'isfinite' ] / Failures: { 'i % 3 == 0' : 'Returned False.' } . Alternately you can provide a dictionary . In that case the key should be one of <callable> , <error_msg> , or <failure_type> , and the value should be one of them or a tuple of them. For example: from valid8 import validate , ValidationFailure from math import isfinite from mini_lambda import i class NotFinite ( ValidationFailure ): help_msg = \"x is not finite\" x = 2 validate ( 'x' , x , custom = { 'x should be fairly small' : i ** 2 < 50 , 'x should be a multiple of 3' : i % 3 == 0 , 'x should be finite' : ( isfinite , NotFinite )}) yields ValidationError [ ValueError ] : Error validating [ x = 2 ] . At least one validation function failed for value 2 . Successes: [ 'i ** 2 < 50' , 'isfinite' ] / Failures: { 'i % 3 == 0' : 'InvalidValue: x should be a multiple of 3. Returned False.' } . Here again, this syntax also works in @validate_arg , @validate_out , @validate_ios , @validate_field , and in the composition operators such as and_() .","title":"Simple syntax"},{"location":"validation_funcs/c_simple_syntax/#simple-syntax-for-validation-functions","text":"We have seen in previous section that validation functions should either return True or None in case of success, that's the only requirement from valid8 standpoint. We also have seen that you can improve them by explicitly transforming them into custom failure raisers . In the next section we will see how to compose several validation functions together. In this section we will show how to both compose several validation functions and augment them into failure raisers, using in a simple and compact syntax . All valid8 entry points except the context manager support this simple syntax. using the simple syntax in the with validation context manager To use this syntax with the with validation context manager, you can use an explicit and_() in the code block. and_ accepts the syntax.","title":"Simple syntax for validation functions"},{"location":"validation_funcs/c_simple_syntax/#1-one-validation-function","text":"You can define a validation function by providing either a <callable> , or a tuple : (<callable>, <error_msg>) , (<callable>, <failure_type>) or (<callable>, <error_msg>, <failure_type>) . <validation_func> should be a callable with one argument: f(val) . It should return True or None in case of success. If it is a mini-lambda expression it will automatically be transformed into a function using mini_lambda.as_function . See ValidationCallable type hint. <err_msg> should be a string, possibly using the template mechanism <failure_type> should be a subclass of ValidationFailure For example we can add a custom message to isfinite : from valid8 import validate from math import inf , isfinite x = inf validate ( 'x' , x , custom = ( isfinite , 'x is not finite' )) yields valid8.entry_points.ValidationError [ ValueError ] : \\ Error validating [ x = inf ] . InvalidValue: x is not finite. \\ Function [ isfinite ] returned [ False ] for value inf. or if you prefer defining a reusable failure class: from valid8 import validate , ValidationFailure from math import inf , isfinite class NotFinite ( ValidationFailure ): help_msg = \"x is not finite\" x = inf validate ( 'x' , x , custom = ( isfinite , NotFinite )) yields ValidationError [ ValueError ] : Error validating [ x = inf ] . NotFinite: x is not finite. Function [ isfinite ] returned [ False ] for value inf. This syntax also works in @validate_arg , @validate_out , @validate_ios , @validate_field , and in the composition operators such as and_() .","title":"1. One validation function"},{"location":"validation_funcs/c_simple_syntax/#2-several-validation-functions","text":"You can easily declare that several validators should be combined with an implicit and_ by providing a non-tuple iterable containing validation function definitions , in other words a list containing <callable> , tuples (<callable>, <error_msg>) , (<callable>, <failure_type>) or (<callable>, <error_msg>, <failure_type>) . For example: from valid8 import validate , ValidationFailure from math import isfinite from mini_lambda import i class NotFinite ( ValidationFailure ): help_msg = \"x is not finite\" x = 2 validate ( 'x' , x , custom = [( i ** 2 < 50 , 'x should be fairly small' ), i % 3 == 0 , ( isfinite , NotFinite )]) yields ValidationError [ ValueError ] : Error validating [ x = 2 ] . At least one validation function failed for value 2 . Successes: [ 'i ** 2 < 50' , 'isfinite' ] / Failures: { 'i % 3 == 0' : 'Returned False.' } . Alternately you can provide a dictionary . In that case the key should be one of <callable> , <error_msg> , or <failure_type> , and the value should be one of them or a tuple of them. For example: from valid8 import validate , ValidationFailure from math import isfinite from mini_lambda import i class NotFinite ( ValidationFailure ): help_msg = \"x is not finite\" x = 2 validate ( 'x' , x , custom = { 'x should be fairly small' : i ** 2 < 50 , 'x should be a multiple of 3' : i % 3 == 0 , 'x should be finite' : ( isfinite , NotFinite )}) yields ValidationError [ ValueError ] : Error validating [ x = 2 ] . At least one validation function failed for value 2 . Successes: [ 'i ** 2 < 50' , 'isfinite' ] / Failures: { 'i % 3 == 0' : 'InvalidValue: x should be a multiple of 3. Returned False.' } . Here again, this syntax also works in @validate_arg , @validate_out , @validate_ios , @validate_field , and in the composition operators such as and_() .","title":"2. Several validation functions"},{"location":"validation_funcs/d_composition/","text":"Built-in composition functions \u00b6 We have seen in previous section that an implicit \"and\" can be easily performed. However in some cases you might need additional ways to compose functions. A few tools are provided out of the box: not_ \u00b6 not_ ( validation_func : ValidationFunc , catch_all : bool = False ) Generates the inverse of the provided validation functions: when the validator returns False or raises a ValidationFailure , this function returns True . Otherwise it raises a DidNotFail failure. By default, exceptions of types other than ValidationFailure are not caught and therefore fail the validation ( catch_all=False ). To change this behaviour you can turn the catch_all parameter to True , in which case all exceptions will be caught instead of just ValidationFailure s. Note that the argument is a single callable. You may use not_all(<validation_functions_list>) as a shortcut for not_(and_(<validation_functions_list>)) to support several validation functions in the 'not'. See help(not_) and_ \u00b6 and_ ( * validation_func : ValidationFuncs ) An 'and' validator: it returns True if all of the provided validators return True , or raises a AtLeastOneFailed failure on the first False received or Exception caught. Note that an implicit and_ is performed if you provide a list of validators to any of the entry points ( validator / validation , @validate_arg , @validate_field ...). For validate you need to use an explicit one in custom=<f> . See help(and_) or_ \u00b6 or_ ( * validation_func : ValidationFuncs ) An 'or' validator: returns True if at least one of the provided validators returns True . All exceptions will be silently caught. In case of failure, a global AllValidatorsFailed failure will be raised, together with details about all validation results. See help(or_) xor_ \u00b6 xor_ ( * validation_func : ValidationFuncs ) A 'xor' validation function: returns True if exactly one of the provided validators returns True . All exceptions will be silently caught. In case of failure, a global XorTooManySuccess or AllValidatorsFailed will be raised, together with details about the various validation results. See help(xor_) not_all \u00b6 not_all ( * validation_func : ValidationFuncs , catch_all : bool = False ) An alias for not_(and_(validators)). See help(not_all) skip_on_none \u00b6 skip_on_none(*validation_func: ValidationFuncs) This function is automatically used if you use none_policy=SKIP , you will probably never need to use it explicitly. If wraps the provided function (or implicit and_ between provided functions) so that None values are not validated and the code continues executing. See help(skip_on_none) fail_on_none \u00b6 fail_on_none(*validation_func: ValidationFuncs) This function is automatically used if you use none_policy=FAIL , you will probably never need to use it explicitly. If wraps the provided function (or implicit and_ between provided functions) so that None values are not validated instead a ValueIsNone failure is raised. See help(fail_on_none)","title":"Composition framework"},{"location":"validation_funcs/d_composition/#built-in-composition-functions","text":"We have seen in previous section that an implicit \"and\" can be easily performed. However in some cases you might need additional ways to compose functions. A few tools are provided out of the box:","title":"Built-in composition functions"},{"location":"validation_funcs/d_composition/#not_","text":"not_ ( validation_func : ValidationFunc , catch_all : bool = False ) Generates the inverse of the provided validation functions: when the validator returns False or raises a ValidationFailure , this function returns True . Otherwise it raises a DidNotFail failure. By default, exceptions of types other than ValidationFailure are not caught and therefore fail the validation ( catch_all=False ). To change this behaviour you can turn the catch_all parameter to True , in which case all exceptions will be caught instead of just ValidationFailure s. Note that the argument is a single callable. You may use not_all(<validation_functions_list>) as a shortcut for not_(and_(<validation_functions_list>)) to support several validation functions in the 'not'. See help(not_)","title":"not_"},{"location":"validation_funcs/d_composition/#and_","text":"and_ ( * validation_func : ValidationFuncs ) An 'and' validator: it returns True if all of the provided validators return True , or raises a AtLeastOneFailed failure on the first False received or Exception caught. Note that an implicit and_ is performed if you provide a list of validators to any of the entry points ( validator / validation , @validate_arg , @validate_field ...). For validate you need to use an explicit one in custom=<f> . See help(and_)","title":"and_"},{"location":"validation_funcs/d_composition/#or_","text":"or_ ( * validation_func : ValidationFuncs ) An 'or' validator: returns True if at least one of the provided validators returns True . All exceptions will be silently caught. In case of failure, a global AllValidatorsFailed failure will be raised, together with details about all validation results. See help(or_)","title":"or_"},{"location":"validation_funcs/d_composition/#xor_","text":"xor_ ( * validation_func : ValidationFuncs ) A 'xor' validation function: returns True if exactly one of the provided validators returns True . All exceptions will be silently caught. In case of failure, a global XorTooManySuccess or AllValidatorsFailed will be raised, together with details about the various validation results. See help(xor_)","title":"xor_"},{"location":"validation_funcs/d_composition/#not_all","text":"not_all ( * validation_func : ValidationFuncs , catch_all : bool = False ) An alias for not_(and_(validators)). See help(not_all)","title":"not_all"},{"location":"validation_funcs/d_composition/#skip_on_none","text":"skip_on_none(*validation_func: ValidationFuncs) This function is automatically used if you use none_policy=SKIP , you will probably never need to use it explicitly. If wraps the provided function (or implicit and_ between provided functions) so that None values are not validated and the code continues executing. See help(skip_on_none)","title":"skip_on_none"},{"location":"validation_funcs/d_composition/#fail_on_none","text":"fail_on_none(*validation_func: ValidationFuncs) This function is automatically used if you use none_policy=FAIL , you will probably never need to use it explicitly. If wraps the provided function (or implicit and_ between provided functions) so that None values are not validated instead a ValueIsNone failure is raised. See help(fail_on_none)","title":"fail_on_none"}]}